"use strict";

// valid filters: 
// greaterThan
// inList
// lessThan
// lessThanOrEqual
// equals
// greaterThanOrEqual
// notEquals
// notNull
// isNull
// between
// notInList
// startsWithExactly
// endsWithExactly
// containsExactly
// startsWith
// endsWith
// contains
// upperCase
// lowerCase
// matchesRegex (note: this takes a string like "thomas.*is.*cool", don't include the outer slashes like /asdf/ and don't pass a regex object ) 
// fuzzy
var FilterExpression = require("./filter-expression");
var _ = require("lodash");

var combineQueries = require("./combine-queries");

function isDateOrNumber(opName) {
  var _arguments = arguments;

  return function () {
    var args = [].slice.call(_arguments);
    if (args.some(function (arg) {
      return !(_.isDate(arg) || _.isString(arg) || _.isNumber(arg));
    })) {
      throw new Error("QueryBuilderError: You must pass a date or number as args to " + opName + ". You passed: Args " + args.join(','));
    }
  };
}
function isArray(opName) {
  return function (arg) {
    if (!_.isArray(arg)) {
      throw new Error("QueryBuilderError: You must pass an array for " + opName + " filters. You passed:  " + arg);
    }
  };
}
function isString(opName) {
  return function (arg) {
    if (!_.isString(arg)) {
      throw new Error("QueryBuilderError: You must pass a string for " + opName + " filters. You passed:  " + arg);
    }
  };
}

function numberOfArgs(opName, argLength) {
  return function () {
    if (arguments.length !== argLength) {
      throw new Error("QueryBuilderError: Args for " + opName + " are of length " + arguments.length + ", but they should be of length " + argLength);
    }
  };
}

var expressionOperators = [{
  opName: "greaterThan",
  sanityChecks: [numberOfArgs("greaterThan", 1), isDateOrNumber("greaterThan")]
}, {
  opName: "inList",
  sanityChecks: [numberOfArgs("inList", 1), isArray("inList")]
}, {
  opName: "lessThan",
  sanityChecks: [numberOfArgs("lessThan", 1), isDateOrNumber("lessThan")]
}, {
  opName: "lessThanOrEqual",
  sanityChecks: [numberOfArgs("lessThanOrEqual", 1), isDateOrNumber("lessThanOrEqual")]
}, {
  opName: "equals",
  sanityChecks: [numberOfArgs("equals", 1)]
}, {
  opName: "greaterThanOrEqual",
  sanityChecks: [numberOfArgs("greaterThanOrEqual", 1), isDateOrNumber("greaterThanOrEqual")]
}, {
  opName: "notEquals",
  sanityChecks: [numberOfArgs("notEquals", 1)]
}, {
  opName: "notNull",
  sanityChecks: [numberOfArgs("notNull", 0)]
}, {
  opName: "isNull",
  sanityChecks: [numberOfArgs("isNull", 0)]
}, {
  opName: "between",
  sanityChecks: [numberOfArgs("between", 2), isDateOrNumber("between")]
}, {
  opName: "notInList",
  sanityChecks: [numberOfArgs("notInList", 1), isArray("notInList")]
}, {
  opName: "startsWithExactly",
  sanityChecks: [numberOfArgs("startsWith", 1), isString("startsWith")]
}, {
  opName: "endsWithExactly",
  sanityChecks: [numberOfArgs("endsWith", 1), isString("endsWith")]
}, {
  opName: "containsExactly",
  sanityChecks: [numberOfArgs("contains", 1), isString("contains")]
}, {
  opName: "startsWith",
  sanityChecks: [numberOfArgs("startsWith", 1), isString("startsWith")]
}, {
  opName: "endsWith",
  sanityChecks: [numberOfArgs("endsWith", 1), isString("endsWith")]
}, {
  opName: "contains",
  sanityChecks: [numberOfArgs("contains", 1), isString("contains")]
}, {
  opName: "notContains",
  sanityChecks: [numberOfArgs("notContains", 1), isString("notContains")]
}, {
  opName: "upperCase",
  sanityChecks: [numberOfArgs("upperCase", 1), isString("upperCase")]
}, {
  opName: "lowerCase",
  sanityChecks: [numberOfArgs("lowerCase", 1), isString("lowerCase")]
}, {
  opName: "matchesRegex",
  sanityChecks: [numberOfArgs("matchesRegex", 1), isString("matchesRegex")]
}, {
  opName: "fuzzy",
  sanityChecks: [numberOfArgs("fuzzy", 1), isString("fuzzy")],
  transform: function transform(arg) {
    // Build Regex String 
    var matchTerm = '';
    // Split all the search terms
    var terms = arg.replace(/\W/g, '').replace(' ', '').split("");
    for (var i = 0; i < terms.length; i++) {
      matchTerm += '.*' + terms[i];
    }
    matchTerm += '.*';
    return {
      newOpName: 'matchesRegex',
      newArgs: [matchTerm]
    };
  }

  // 'subString', //tnr: not yet implemented
  // 'dateOnly', //tnr: not yet implemented
}];

module.exports = function () {
  // to be implemented
  //
  // filter - done
  // lessThan - done
  // lessThanOrEqual - done
  // greaterThan - done
  // greaterThanOrEqual - done
  // equals - done
  // notEquals - done
  // notNull
  // isNull
  // between
  // inList - done
  // notInList
  // related - done
  // notRelated - done
  // startsWith LIKE adsd%
  // endsWith
  // contains LIKE
  // notContains NOT LIKE
  // dateOnly
  // upperCase
  // lowerCase
  // subString
  // matchesRegex
  // count - Done

  // log("FilterBuilder in QueryBuilder");
  // log(FilterBuilder);

  function QueryBuilder(entity) {
    this.query = {};

    if (entity == null) throw new Error("You must pass the name of the model being filtered!");

    if (typeof entity === "string") {
      this.query = {
        __objectType: "query",
        type: "root",
        entity: entity,
        filters: []
      };
    } else {
      var subQuery = entity;
      this.query = {
        type: "subquery",
        key: subQuery.key,
        entity: subQuery.entity,
        foreignKey: subQuery.foreignKey,
        modifier: subQuery.modifier,
        filters: [],
        countExpression: undefined
      };
      this.parentBuilder = subQuery.parentBuilder;
      this.toFilter = function (filterBuilder, name) {
        this.query.foreignKey = name;
        return this.toJSON();
      };
    }
  }

  QueryBuilder.combineQueries = combineQueries;

  QueryBuilder.prototype.field = function (fieldName) {
    return {
      __objectType: "field",
      field: fieldName
    };
  };

  QueryBuilder.prototype.related = function (relatedEntity) {
    var tokens = relatedEntity.split(".");
    var entity = tokens[0];
    var key = tokens[1];

    // log("FilterBuilder in related");
    // log(FilterBuilder);

    return createSubQueryBuilder(this, entity, key);
  };

  QueryBuilder.prototype.notRelated = function (relatedEntity) {
    var tokens = relatedEntity.split(".");
    var entity = tokens[0];
    var key = tokens[1];

    // log("FilterBuilder in notRelated");
    // log(FilterBuilder);

    return createSubQueryBuilder(this, entity, key, "not");
  };

  QueryBuilder.prototype.toJSON = function () {
    var qry = JSON.parse(JSON.stringify(this.query));
    if (qry.filters.length > 1) {
      qry.filters = [{
        type: "group",
        operator: 'and',
        chainedWith: 'and',
        filters: qry.filters
      }];
    }
    return qry;
  };

  QueryBuilder.prototype.convertToFilter = function (argDef, operator) {
    var _this = this;

    var whereArgs = {};
    var filters = [];

    _.each(argDef, function (arg, name) {
      // log(name);
      // if(arg.constructor){
      //     log(arg.constructor.name)
      // }else{
      //     log("not a prototype")
      // }
      if (!isFilterExpresionOrSubQuery(name, arg)) {
        if (Array.isArray(arg)) {
          filters.push(_this.inList(arg).toFilter(_this, name));
        } else {
          //log("Is Where Filter: " + name);
          whereArgs[name] = arg;
        }
      } else {
        //log("Is Expression or SubQuery Filter: " + name);
        filters.push(arg.toFilter(_this, name));
      }
    });
    if (_.keys(whereArgs).length > 0) {
      filters.unshift({
        type: "where",
        args: whereArgs
      });
    }

    if (filters.length === 1) {
      return filters[0];
    }
    var filterDef = {
      type: "group",
      operator: operator || "and",
      filters: filters
    };
    return filterDef;
  };

  QueryBuilder.prototype.where = function () {
    var args = [].slice.call(arguments);
    return this.whereAll(args);
  };

  QueryBuilder.prototype.orWhere = function () {
    var args = [].slice.call(arguments);
    return this.orWhereAll(args);
  };

  QueryBuilder.prototype.andWhere = function () {
    var args = [].slice.call(arguments);
    return this.andWhereAll(args);
  };

  QueryBuilder.prototype.whereAny = function () {
    var args = [].slice.call(arguments);
    return whereAny(this, args);
  };

  QueryBuilder.prototype.whereAll = function () {
    var args = [].slice.call(arguments);
    return whereAll(this, args);
  };

  QueryBuilder.prototype.andWhereAny = function () {
    var args = [].slice.call(arguments);
    return whereAny(this, args, "and");
  };

  QueryBuilder.prototype.orWhereAny = function () {
    var args = [].slice.call(arguments);
    return whereAny(this, args, "or");
  };

  QueryBuilder.prototype.andWhereAll = function () {
    var args = [].slice.call(arguments);
    return whereAll(this, args, "and");
  };

  QueryBuilder.prototype.orWhereAll = function () {
    var args = [].slice.call(arguments);
    return whereAll(this, args, "or");
  };

  QueryBuilder.prototype.count = function () {
    var args = [].slice.call(arguments);
    if (this.query.type === "subquery") {
      if (this.query.countExpression) {
        throw new Error("QueryBuilder subquery can only have one count expression");
      }
      this.query.countExpression = args[0].toFilter(this, "count");
    } else {
      throw new Error("QueryBuilder is not subquery type on count expression");
    }

    return this;
  };
  QueryBuilder.ExpressionJson = {};
  attachExpressionFunctions();

  return QueryBuilder;

  function createSubQueryBuilder(qb, entity, key, modifier) {
    return new QueryBuilder({
      parentBuilder: qb,
      entity: entity,
      key: key,
      modifier: modifier
    });
  }

  function attachExpressionFunctions() {
    expressionOperators.forEach(function (_ref) {
      var opName = _ref.opName,
          sanityChecks = _ref.sanityChecks,
          transform = _ref.transform;

      var filter = function filter() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var argsToUse = args;
        var opNameToUse = opName;
        if (transform) {
          var _transform = transform.apply(undefined, args),
              newOpName = _transform.newOpName,
              newArgs = _transform.newArgs;

          argsToUse = newArgs;
          opNameToUse = newOpName;
        }
        sanityChecks.forEach(function (sanityCheck) {
          sanityCheck.apply(undefined, args);
        });
        return new FilterExpression(opNameToUse, argsToUse);
      };
      QueryBuilder.prototype[opName] = filter;
      QueryBuilder.ExpressionJson[opName] = filter;
    });
  }

  function isFilterExpresionOrSubQuery(name, arg) {
    if (arg instanceof FilterExpression) return true;
    if (arg instanceof QueryBuilder) return true;
    return false;
  }

  function whereAny(filterBuilder, whereArgs, chainedWith) {
    return where(filterBuilder, "or", whereArgs, chainedWith);
  }

  function whereAll(filterBuilder, whereArgs, chainedWith) {
    return where(filterBuilder, "and", whereArgs, chainedWith);
  }

  function where(filterBuilder, operator, whereArgs, chainedWith) {
    if (!Array.isArray(whereArgs)) return where(filterBuilder, operator, [whereArgs], chainedWith);

    var filterDef = {
      type: "group",
      operator: operator,
      chainedWith: chainedWith,
      filters: []
    };

    whereArgs.forEach(function (arg) {
      //add check for object type TODO
      var filter = filterBuilder.convertToFilter(arg, operator);
      filterDef.filters.push(filter);
    });

    // if (filterDef.filters.length === 1) {
    //   filterBuilder.query.filters.push(filterDef.filters[0]);
    // } else {
    //   filterBuilder.query.filters.push(filterDef);
    // }
    filterBuilder.query.filters.push(filterDef);
    return filterBuilder;
  }
}();