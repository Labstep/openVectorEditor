import { Component } from 'react';
import { observe, unobserve, raw, isObservable } from '@nx-js/observer-util';
export { observable as store } from '@nx-js/observer-util';

var COMPONENT = Symbol('owner component');
var DUMMY_STATE = {};

function view(Comp, ref) {
  if ( ref === void 0 ) ref = {};
  var rawDevtool = ref.devtool;

  var isStatelessComp = !(Comp.prototype && Comp.prototype.isReactComponent);
  var BaseComp = isStatelessComp ? Component : Comp;

  var devtool = rawDevtool ? function (operation) { return rawDevtool(Object.assign({ Component: Comp }, operation)); } : undefined;

  // return a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount
  // it decides when to run the new reactive methods and when to proxy to the original methods
  var ReactiveHOC = (function (BaseComp) {
    function ReactiveHOC(props, context) {
      var this$1 = this;

      BaseComp.call(this, props, context);

      this.state = this.state || {};
      this.state[COMPONENT] = this;
      // create a reactive render for the component
      // run a dummy setState to schedule a new reactive render, avoid forceUpdate
      this.render = observe(this.render, {
        scheduler: function () { return this$1.setState(DUMMY_STATE); },
        debugger: devtool,
        lazy: true
      });
    }

    if ( BaseComp ) ReactiveHOC.__proto__ = BaseComp;
    ReactiveHOC.prototype = Object.create( BaseComp && BaseComp.prototype );
    ReactiveHOC.prototype.constructor = ReactiveHOC;

    ReactiveHOC.prototype.render = function render () {
      return isStatelessComp ? Comp(this.props, this.context) : BaseComp.prototype.render.call(this);
    };

    // react should trigger updates on prop changes, while easyState handles store changes
    ReactiveHOC.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
      var ref = this;
      var props = ref.props;
      var state = ref.state;

      // respect the case when user prohibits updates
      if (BaseComp.prototype.shouldComponentUpdate && !BaseComp.prototype.shouldComponentUpdate.call(this, nextProps, nextState)) {
        devtool && devtool({ type: 'render', renderType: 'blocked' });
        return false;
      }

      // return true if it is a reactive render or state changes
      if (state !== nextState) {
        devtool && devtool({ type: 'render', renderType: 'reactive' });
        return true;
      }

      // the component should update if any of its props shallowly changed value
      var keys = Object.keys(props);
      var nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== keys.length || nextKeys.some(function (key) { return props[key] !== nextProps[key]; })) {
        devtool && devtool({
          type: 'render',
          renderType: 'normal',
          props: nextProps,
          oldProps: props
        });
        return true;
      }
      return false;
    };

    // add a custom deriveStoresFromProps lifecyle method
    ReactiveHOC.getDerivedStateFromProps = function getDerivedStateFromProps (props, state) {
      if (BaseComp.deriveStoresFromProps) {
        // inject all local stores and let the user mutate them directly
        var stores = mapStateToStores(state);
        BaseComp.deriveStoresFromProps.apply(this, [ props ].concat( stores ));
      }
      // respect user defined getDerivedStateFromProps
      if (BaseComp.getDerivedStateFromProps) {
        return BaseComp.getDerivedStateFromProps.call(this, props, state);
      }
      return null;
    };

    ReactiveHOC.prototype.componentWillUnmount = function componentWillUnmount () {
      // call user defined componentWillUnmount
      if (BaseComp.prototype.componentWillUnmount) {
        BaseComp.prototype.componentWillUnmount.call(this);
      }
      // clean up memory used by Easy State
      unobserve(this.render);
    };

    return ReactiveHOC;
  }(BaseComp));

  ReactiveHOC.displayName = Comp.displayName || Comp.name;
  // static props are inherited by class components,
  // but have to be copied for function components
  if (isStatelessComp) {
    for (var i = 0, list = Object.keys(Comp); i < list.length; i += 1) {
      var key = list[i];

      ReactiveHOC[key] = Comp[key];
    }
  }

  return ReactiveHOC;
}

function mapStateToStores(state) {
  // find store properties and map them to their none observable raw value
  // to do not trigger none static this.setState calls
  // from the static getDerivedStateFromProps lifecycle method
  var component = state[COMPONENT];
  return Object.keys(component).map(function (key) { return component[key]; }).filter(isObservable).map(raw);
}

export { view };
