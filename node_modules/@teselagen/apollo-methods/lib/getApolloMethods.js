"use strict";

exports.__esModule = true;

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = getApolloMethods;

var _lodash = require("lodash");

var _withQuery = require("./withQuery");

var _withQuery2 = _interopRequireDefault(_withQuery);

var _withDelete = require("./withDelete");

var _withDelete2 = _interopRequireDefault(_withDelete);

var _withUpsert = require("./withUpsert");

var _withUpsert2 = _interopRequireDefault(_withUpsert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function getApolloMethods(client) {

  /**
   * If `query` tries to query more than 50 items this function
   * will group them into queries of 50 at a time and then
   * return them together
   */
  var safeQuery = function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(fragment) {
      var passedOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var unsafe, nameOverride, _passedOptions$pageSi, pageSize, showToast, _passedOptions$modelN, modelNameToReadableName, maybeOptions, pageVariables, options, page, items, totalResults, clearToast, pageOfItems, readableName, toastMessage;

      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              unsafe = passedOptions.unsafe, nameOverride = passedOptions.nameOverride, _passedOptions$pageSi = passedOptions.pageSize, pageSize = _passedOptions$pageSi === undefined ? 50 : _passedOptions$pageSi, showToast = passedOptions.showToast, _passedOptions$modelN = passedOptions.modelNameToReadableName, modelNameToReadableName = _passedOptions$modelN === undefined ? function () {} : _passedOptions$modelN, maybeOptions = _objectWithoutProperties(passedOptions, ["unsafe", "nameOverride", "pageSize", "showToast", "modelNameToReadableName"]);
              // not plural

              if (!(unsafe || (0, _lodash.get)(maybeOptions, "variables.id") || (0, _lodash.get)(maybeOptions, "variables.code"))) {
                _context.next = 5;
                break;
              }

              _context.next = 4;
              return query(fragment, maybeOptions);

            case 4:
              return _context.abrupt("return", _context.sent);

            case 5:
              if (!(0, _lodash.get)(maybeOptions, "variables.pageSize")) {
                _context.next = 9;
                break;
              }

              _context.next = 8;
              return query(fragment, _extends({
                isPlural: true
              }, maybeOptions));

            case 8:
              return _context.abrupt("return", _context.sent);

            case 9:
              pageVariables = {
                pageSize: pageSize
              };
              options = {
                isPlural: true,
                variables: pageVariables
              };


              if (maybeOptions) {
                options = _extends({
                  isPlural: true
                }, maybeOptions, {
                  variables: _extends({}, pageVariables, maybeOptions.variables)
                });
              }

              page = 1;
              items = [];
              totalResults = 1;
              clearToast = void 0;

            case 16:
              if (!(items.length < totalResults)) {
                _context.next = 26;
                break;
              }

              options.variables.pageNumber = page++;
              _context.next = 20;
              return query(fragment, options);

            case 20:
              pageOfItems = _context.sent;

              items = items.concat(pageOfItems);
              totalResults = pageOfItems.totalResults;
              if (showToast && totalResults > 100) {
                readableName = nameOverride || modelNameToReadableName((0, _lodash.get)(items, "[0].__typename"), {
                  plural: true
                });
                toastMessage = "Loading " + readableName + ":";

                clearToast = showToast(nameOverride ? "Loading " + nameOverride : toastMessage, items.length / totalResults, clearToast && clearToast.key);
              }
              _context.next = 16;
              break;

            case 26:
              items.totalResults = totalResults;
              if (clearToast) {
                setTimeout(function () {
                  clearToast();
                }, 1500);
              }
              return _context.abrupt("return", items);

            case 29:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function safeQuery(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var safeDelete = function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
      var _ref3;

      var values,
          _args2 = arguments;
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              values = (_ref3 = _args2.length - 1, _args2.length <= _ref3 ? undefined : _args2[_ref3]);

              if (!(Array.isArray(values) && !values.length)) {
                _context2.next = 5;
                break;
              }

              return _context2.abrupt("return", []);

            case 5:
              _context2.next = 7;
              return deleteFn.apply(undefined, _args2);

            case 7:
              return _context2.abrupt("return", _context2.sent);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    return function safeDelete() {
      return _ref2.apply(this, arguments);
    };
  }();

  var upsert = function upsert(fragment, options, valueOrValues) {
    var optionsToUse = {};
    var valueOrValuesToUse = valueOrValues;
    if (!valueOrValues) {
      valueOrValuesToUse = options;
    } else {
      optionsToUse = options;
    }
    return (0, _withUpsert2.default)(fragment, _extends({
      asFunction: true,
      client: client
    }, optionsToUse))(valueOrValuesToUse, optionsToUse);
  };

  // /**
  // DEPRECATED: all functionality has been added to withUpsert
  //  * If `upsert` is called with an empty array for the values,
  //  * it will throw an error. This function factory can preclude
  //  * the need to make sure the values being upserted aren't empty.
  //  *
  //  * secondly, if trying to upsert more than 50 items it will split
  //  * them into groups and upsert 50 at a time.
  //  */
  // async function safeUpsert(...args) {
  //   const values = args.pop();
  //   if (Array.isArray(values) && !values.length) return [];
  //   else {
  //     if (values.length > SAFE_UPSERT_PAGE_SIZE) {
  //       const groupedVals = chunk(values, SAFE_UPSERT_PAGE_SIZE);
  //       let toReturn = [];
  //       for (const valGroup of groupedVals) {
  //         toReturn = toReturn.concat(await upsert(...args, valGroup));
  //       }
  //       return toReturn;
  //     } else {
  //       return await upsert(...args, values);
  //     }
  //   }
  // }

  var query = function query(fragment, options) {
    return (0, _withQuery2.default)(fragment, _extends({ asFunction: true, client: client }, options))();
  };

  function makeSafeQueryWithToast(showToast, modelNameToReadableName) {
    return function (fragment) {
      var passedOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return safeQuery(fragment, _extends({}, passedOptions, {
        showToast: showToast,
        modelNameToReadableName: modelNameToReadableName
      }));
    };
  }

  var deleteFn = function deleteFn(fragment, options, idOrIdsToDelete) {
    var optionsToUse = {};
    var idOrIdsToDeleteToUse = idOrIdsToDelete;
    if (!idOrIdsToDeleteToUse) {
      idOrIdsToDeleteToUse = options;
    } else {
      optionsToUse = options;
    }
    return (0, _withDelete2.default)(fragment, _extends({
      asFunction: true,
      client: client
    }, optionsToUse))(idOrIdsToDeleteToUse, optionsToUse);
  };

  return {
    upsert: upsert,
    safeUpsert: upsert,
    query: safeQuery,
    safeQuery: safeQuery,
    makeSafeQueryWithToast: makeSafeQueryWithToast,
    delete: safeDelete,
    safeDelete: safeDelete
  };
}
module.exports = exports["default"];