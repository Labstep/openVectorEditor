"use strict";

exports.__esModule = true;

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var getSafeUpsertResults = function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref6) {
    var upsertFn = _ref6.upsertFn,
        values = _ref6.values,
        createName = _ref6.createName,
        updateName = _ref6.updateName,
        _ref6$pageSize = _ref6.pageSize,
        pageSize = _ref6$pageSize === undefined ? _constants.SAFE_UPSERT_PAGE_SIZE : _ref6$pageSize,
        _userOptions = _ref6.userOptions,
        isUpdate = _ref6.isUpdate;

    var userOptions, results, addToResults, groupedVals, _iterator, _isArray, _i, _ref7, valGroup;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            userOptions = _userOptions || [];
            results = [];

            addToResults = function addToResults(res) {
              var returnInfo = res.data[isUpdate ? updateName : createName][isUpdate ? "updatedItemsCursor" : "createdItemsCursor"];
              results = results.concat(returnInfo.results);
              results.totalResults = returnInfo.totalResults;
            };

            if (!(values.length > pageSize)) {
              _context.next = 26;
              break;
            }

            groupedVals = (0, _lodash.chunk)(values, pageSize);
            _iterator = groupedVals, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

          case 6:
            if (!_isArray) {
              _context.next = 12;
              break;
            }

            if (!(_i >= _iterator.length)) {
              _context.next = 9;
              break;
            }

            return _context.abrupt("break", 24);

          case 9:
            _ref7 = _iterator[_i++];
            _context.next = 16;
            break;

          case 12:
            _i = _iterator.next();

            if (!_i.done) {
              _context.next = 15;
              break;
            }

            return _context.abrupt("break", 24);

          case 15:
            _ref7 = _i.value;

          case 16:
            valGroup = _ref7;
            _context.t0 = addToResults;
            _context.next = 20;
            return upsertFn.apply(undefined, [valGroup].concat(userOptions));

          case 20:
            _context.t1 = _context.sent;
            (0, _context.t0)(_context.t1);

          case 22:
            _context.next = 6;
            break;

          case 24:
            _context.next = 31;
            break;

          case 26:
            _context.t2 = addToResults;
            _context.next = 29;
            return upsertFn.apply(undefined, [values].concat(userOptions));

          case 29:
            _context.t3 = _context.sent;
            (0, _context.t2)(_context.t3);

          case 31:
            return _context.abrupt("return", results);

          case 32:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function getSafeUpsertResults(_x2) {
    return _ref5.apply(this, arguments);
  };
}();

var _templateObject = _taggedTemplateLiteralLoose(["\n    mutation ", "($input: [", "Input]) {\n      ", "(input: $input) {\n        createdItemsCursor {\n          ", "\n        }\n      }\n    }\n    ", "\n  "], ["\n    mutation ", "($input: [", "Input]) {\n      ", "(input: $input) {\n        createdItemsCursor {\n          ", "\n        }\n      }\n    }\n    ", "\n  "]),
    _templateObject2 = _taggedTemplateLiteralLoose(["\n    mutation ", "($input: [", "Input]) {\n      ", "(input: $input) {\n        updatedItemsCursor {\n          ", "\n        }\n      }\n    }\n    ", "\n  "], ["\n    mutation ", "($input: [", "Input]) {\n      ", "(input: $input) {\n        updatedItemsCursor {\n          ", "\n        }\n      }\n    }\n    ", "\n  "]);

exports.default = withUpsert;

var _reactApollo = require("react-apollo");

var _lodash = require("lodash");

var _graphqlTag = require("graphql-tag");

var _graphqlTag2 = _interopRequireDefault(_graphqlTag);

var _pascalCase = require("pascal-case");

var _pascalCase2 = _interopRequireDefault(_pascalCase);

var _recompose = require("recompose");

var _generateFragmentWithFields = require("./utils/generateFragmentWithFields");

var _generateFragmentWithFields2 = _interopRequireDefault(_generateFragmentWithFields);

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/**
 * withUpsert
 * @param {string | gql fragment} nameOrFragment supply either a name or a top-level fragment
 * @param {options} options
 * @typedef {object} options
 * @property {string} mutationName - optional rename of the default upsert function withXXXX to whatever you want
 * @property {[queryNameStrings]} refetchQueries -
 * @property {boolean} showError - default=true -- whether or not to show a default error message on failure
 * @property {obj | function} extraMutateArgs - obj or function that returns obj to get passed to the actual mutation call
 * @property {boolean} asFunction - if true, this gives you back a function you can call directly instead of a HOC
 * @property {boolean} asMutationObj - if true, this gives you back an array of [query, variables, getResponse] that you can use with any http client
 * @property {string} idAs - if not using a fragment, you get an id field back as default. But, if the record doesn't have an id field, and instead has a 'code', you can set idAs: 'code'
 * @property {boolean} forceCreate - sometimes the thing you're creating won't have an id field (it might have a code or something else as its primary key). This lets you override the default behavior of updating if no id is found
 * @property {boolean} forceUpdate - sometimes the thing you're updating might have an id field. This lets you override that. This lets you override the default behavior of creating if an id is found
 * @property {boolean} excludeResults - don't fetch back result entities after update or create
 * @return upsertXXXX function that takes an object or array of objects to upsert. It returns a promise resolving to an array of created/updated outputs
 */

function withUpsert(nameOrFragment) {
  var _withHandlers;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var mutationName = options.mutationName,
      _options$extraMutateA = options.extraMutateArgs,
      extraMutateArgs = _options$extraMutateA === undefined ? {} : _options$extraMutateA,
      asFunction = options.asFunction,
      idAs = options.idAs,
      asMutationObj = options.asMutationObj,
      topLevelForceCreate = options.forceCreate,
      topLevelForceUpdate = options.forceUpdate,
      client = options.client,
      refetchQueries = options.refetchQueries,
      _options$showError = options.showError,
      showError = _options$showError === undefined ? true : _options$showError,
      _options$excludeResul = options.excludeResults,
      excludeResults = _options$excludeResul === undefined ? false : _options$excludeResul,
      pageSize = options.pageSize,
      _options$optimistic = options.optimistic,
      optimistic = _options$optimistic === undefined ? false : _options$optimistic,
      optimisticValues = options.optimisticValues,
      rest = _objectWithoutProperties(options, ["mutationName", "extraMutateArgs", "asFunction", "idAs", "asMutationObj", "forceCreate", "forceUpdate", "client", "refetchQueries", "showError", "excludeResults", "pageSize", "optimistic", "optimisticValues"]);

  var fragment = typeof nameOrFragment === "string" ? null : nameOrFragment;
  if (Array.isArray(fragment)) {
    fragment = _generateFragmentWithFields2.default.apply(undefined, fragment);
  }
  var modelName = fragment ? (0, _lodash.get)(fragment, "definitions[0].typeCondition.name.value") : nameOrFragment;
  var name = fragment ? fragment.definitions[0].typeCondition.name.value : nameOrFragment;

  // const {fragment, extraMutateArgs} = options
  var fragName = fragment && fragment.definitions[0].name.value;
  var pascalCaseName = (0, _pascalCase2.default)(name);
  var createName = "create" + pascalCaseName;
  var resultString = (!excludeResults ? "results {\n    " + (fragName ? "..." + fragName : idAs || "id") + "\n  }" : "") + "\n  totalResults";
  /* eslint-disable */
  var createMutation = (0, _graphqlTag2.default)(_templateObject, createName, createName, createName, resultString, fragment ? fragment : "");
  /* eslint-enable */

  var updateName = "update" + pascalCaseName;
  /* eslint-disable */
  var updateMutation = (0, _graphqlTag2.default)(_templateObject2, updateName, updateName, updateName, resultString, fragment ? fragment : "");
  /* eslint-enable */

  var getExtraMutateArgs = function getExtraMutateArgs() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var runtimeOptions = args && args[1];
    var extraMutateArgsToUse = runtimeOptions && runtimeOptions.extraMutateArgs ? runtimeOptions.extraMutateArgs : extraMutateArgs;
    var extraArgs = {};
    if (typeof extraMutateArgsToUse === "function") {
      extraArgs = _extends({}, extraArgs, extraMutateArgsToUse.apply(undefined, args));
    } else {
      extraArgs = _extends({}, extraArgs, extraMutateArgsToUse);
    }
    return extraArgs;
  };

  if (asFunction || asMutationObj) {
    if (!client && !asMutationObj) return console.error("You need to pass the apollo client to withUpsert if using as a function");
    return function upsert(valueOrValues, options) {
      var values = Array.isArray(valueOrValues) ? valueOrValues : [valueOrValues];
      if (!valueOrValues || !values.length) return [];
      var isUpdate = !!(values[0].id || values[0].code);
      if (topLevelForceCreate) {
        isUpdate = false;
      }
      if (topLevelForceUpdate) {
        isUpdate = true;
      }
      var mutation = isUpdate ? updateMutation : createMutation;
      if (asMutationObj) {
        return [
        //query
        mutation,
        //variables
        {
          input: values
        },
        //getResponse
        function (_res) {
          var res = _res && _res.body || _res;

          var returnInfo = res.data[isUpdate ? updateName : createName][isUpdate ? "updatedItemsCursor" : "createdItemsCursor"];
          var results = returnInfo.results;
          results = [].concat(results);
          results.totalResults = returnInfo.totalResults;
          return excludeResults ? results.totalResults : results;
        }];
      }
      if (!valueOrValues || !values.length) return Promise.resolve([]);

      var upsertFn = function upsertFn(values) {
        var customOptions = {};
        if (optimistic) {
          customOptions.optimisticResponse = getOptimisticResponse(modelName, optimisticValues || values);
        }
        return client.mutate(_extends({
          mutation: mutation,
          variables: {
            input: values
          },
          refetchQueries: refetchQueries
        }, customOptions, rest, options));
      };

      return getSafeUpsertResults({
        upsertFn: upsertFn,
        values: values,
        createName: createName,
        pageSize: pageSize,
        updateName: updateName,
        isUpdate: isUpdate
      });

      // DEPRECATED
      // return client
      //   .mutate({
      //     mutation: isUpdate ? updateMutation : createMutation,
      //     name: "createDataFile",
      //     variables: {
      //       input: values
      //     },
      //     ...rest,
      //     ...options
      //   })
      //   .then(function(res) {
      //     const resultInfo =
      //       res.data[isUpdate ? updateName : createName][
      //         isUpdate ? "updatedItemsCursor" : "createdItemsCursor"
      //       ];
      //     return Promise.resolve([])(
      //       excludeResults ? resultInfo.totalResults : resultInfo.results
      //     );
      //   });
    };
  }

  return (0, _recompose.compose)((0, _reactApollo.graphql)(createMutation, _extends({
    name: "createItem",
    props: function props(_ref) {
      var _createItem = _ref.createItem;

      return {
        createItem: function createItem() {
          var input = arguments.length <= 0 ? undefined : arguments[0];

          var _ref2 = (arguments.length <= 1 ? undefined : arguments[1]) || {},
              update = _ref2.update;

          return _createItem(_extends({
            variables: {
              input: input
            },
            update: update,
            refetchQueries: refetchQueries
          }, getExtraMutateArgs.apply(undefined, arguments)));
        }
      };
    }
  }, rest)), (0, _reactApollo.graphql)(updateMutation, _extends({
    name: "updateItem",
    props: function props(_ref3) {
      var _updateItem = _ref3.updateItem;

      return {
        updateItem: function updateItem() {
          var input = arguments.length <= 0 ? undefined : arguments[0];

          var _ref4 = (arguments.length <= 1 ? undefined : arguments[1]) || {},
              update = _ref4.update;

          return _updateItem(_extends({
            variables: {
              input: input
            },
            update: update,
            refetchQueries: refetchQueries
          }, optimistic && {
            optimisticResponse: getOptimisticResponse(modelName, input)
          }, getExtraMutateArgs.apply(undefined, arguments)));
        }
      };
    }
  }, rest)), (0, _recompose.withHandlers)((_withHandlers = {
    createItem: undefined,
    updateItem: undefined
  }, _withHandlers[mutationName || "upsert" + pascalCaseName] = function (ownProps) {
    return function (valueOrValues) {
      for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }

      var createItem = ownProps.createItem,
          updateItem = ownProps.updateItem,
          _ownProps$apolloOptio = ownProps.apolloOptions,
          apolloOptions = _ownProps$apolloOptio === undefined ? {} : _ownProps$apolloOptio;
      var _apolloOptions$forceC = apolloOptions.forceCreate,
          forceCreate = _apolloOptions$forceC === undefined ? topLevelForceCreate : _apolloOptions$forceC,
          _apolloOptions$forceU = apolloOptions.forceUpdate,
          forceUpdate = _apolloOptions$forceU === undefined ? topLevelForceUpdate : _apolloOptions$forceU;
      //the upsertXXX function is the only thing we should be calling

      var values = Array.isArray(valueOrValues) ? valueOrValues : [valueOrValues];
      if (!valueOrValues || !values.length) return [];
      var isUpdate = !!(values[0].id || values[0].code);
      if (forceCreate) {
        isUpdate = false;
      }
      if (forceUpdate) {
        isUpdate = true;
      }
      var upsertFn = isUpdate ? updateItem : createItem;
      try {
        return getSafeUpsertResults({
          upsertFn: upsertFn,
          values: values,
          createName: createName,
          updateName: updateName,
          userOptions: rest,
          isUpdate: isUpdate
        });
      } catch (e) {
        if (showError) {
          window.toastr && window.toastr.error("Error " + (isUpdate ? "updating" : "creating") + " " + pascalCaseName);
          console.error("withUpsert " + pascalCaseName + " Error:", e);
        }
        throw e; //rethrow the error so it can be caught again if need be
      }
      // DEPRECATED
      // return (isUpdate ? updateItem : createItem)(values, ...rest)
      //   .then(function(res) {
      //     const returnInfo =
      //       res.data[isUpdate ? updateName : createName][
      //         isUpdate ? "updatedItemsCursor" : "createdItemsCursor"
      //       ];
      //     let results = returnInfo.results;
      //     results = [...results];
      //     results.totalResults = returnInfo.totalResults;
      //     return Promise.resolve(results);
      //   })
      //   .catch(e => {
      //     if (showError) {
      //       window.toastr &&
      //         window.toastr.error(
      //           `Error ${
      //             isUpdate ? "updating" : "creating"
      //           } ${pascalCaseName}`
      //         );
      //       console.error(`withUpsert ${pascalCaseName} Error:`, e);
      //     }
      //     throw e; //rethrow the error so it can be caught again if need be
      //   });
    };
  }, _withHandlers)));
}

function getOptimisticResponse(model, values) {
  var _ref8;

  var upperedModel = (0, _lodash.upperFirst)(model);

  return _ref8 = {}, _ref8["update" + upperedModel] = {
    __typename: "update" + upperedModel + "Payload",
    updatedItemsCursor: {
      __typename: model + "CursorResult",
      results: values.map(function (value) {
        return _extends({}, value, {
          __typename: model
        });
      }),
      totalResults: values.length
    }
  }, _ref8;
}
module.exports = exports["default"];