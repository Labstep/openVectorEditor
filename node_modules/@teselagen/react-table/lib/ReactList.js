'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-empty */
/* eslint-disable no-cond-assign */
/* eslint-disable no-cond-assign */
/* eslint-disable default-case */
/* eslint-disable default-case */
/* eslint-disable no-cond-assign */
// import module from 'module';


var CLIENT_SIZE_KEYS = { x: 'clientWidth', y: 'clientHeight' };
var CLIENT_START_KEYS = { x: 'clientTop', y: 'clientLeft' };
var INNER_SIZE_KEYS = { x: 'innerWidth', y: 'innerHeight' };
var OFFSET_SIZE_KEYS = { x: 'offsetWidth', y: 'offsetHeight' };
var OFFSET_START_KEYS = { x: 'offsetLeft', y: 'offsetTop' };
var OVERFLOW_KEYS = { x: 'overflowX', y: 'overflowY' };
var SCROLL_SIZE_KEYS = { x: 'scrollWidth', y: 'scrollHeight' };
var SCROLL_START_KEYS = { x: 'scrollLeft', y: 'scrollTop' };
var SIZE_KEYS = { x: 'minWidth', y: 'minHeight' };

var NOOP = function NOOP() {};

// If a browser doesn't support the `options` argument to
// add/removeEventListener, we need to check, otherwise we will
// accidentally set `capture` with a truthy value.
var PASSIVE = function () {
  if (typeof window === 'undefined') return false;
  var hasSupport = false;
  try {
    document.createElement('div').addEventListener('test', NOOP, {
      get passive() {
        hasSupport = true;
        return false;
      }
    });
  } catch (e) {
    // noop
  }
  return hasSupport;
}() ? { passive: true } : false;

var UNSTABLE_MESSAGE = 'ReactList failed to reach a stable state.';
var MAX_SYNC_UPDATES = 100;

var isEqualSubset = function isEqualSubset(a, b) {
  for (var key in b) {
    if (a[key] !== b[key]) return false;
  }return true;
};

var ReactList = function (_React$Component) {
  _inherits(ReactList, _React$Component);

  function ReactList(props) {
    _classCallCheck(this, ReactList);

    var _this = _possibleConstructorReturn(this, (ReactList.__proto__ || Object.getPrototypeOf(ReactList)).call(this, props));

    var initialIndex = props.initialIndex;

    var itemsPerRow = 1;

    var _this$constrain = _this.constrain(initialIndex, 0, itemsPerRow, props),
        from = _this$constrain.from,
        size = _this$constrain.size;

    _this.state = { from: from, size: size, itemsPerRow: itemsPerRow };
    _this.cache = {};
    _this.prevPrevState = {};
    _this.unstable = false;
    _this.updateCounter = 0;
    return _this;
  }

  //tnr: commenting this out.. not sure if it is actually needed
  // UNSAFE_componentWillReceiveProps(nextProps) {
  //   let { from, size, itemsPerRow } = this.state;
  //   if (nextProps.clearCache) this.cache = {};
  //   this.maybeSetState(
  //     this.constrain(from, size, itemsPerRow, nextProps),
  //     NOOP
  //   );
  // }

  _createClass(ReactList, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateFrame = this.updateFrame.bind(this);
      window.addEventListener('resize', this.updateFrame);
      this.updateFrame(this.scrollTo.bind(this, this.props.initialIndex));
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      var _this2 = this;

      // If the list has reached an unstable state, prevent an infinite loop.
      if (this.unstable) return;

      if (++this.updateCounter > MAX_SYNC_UPDATES) {
        this.unstable = true;
        return console.error(UNSTABLE_MESSAGE);
      }

      if (!this.updateCounterTimeoutId) {
        this.updateCounterTimeoutId = setTimeout(function () {
          _this2.updateCounter = 0;
          delete _this2.updateCounterTimeoutId;
        }, 0);
      }
      // this.dontUpdate = true;
      this.updateFrame();

      //TNR: extra code to 'fix' the scroll height when scrolling upwards
      //tnr commenting this out because we are now doing a better job of calculating row heights
      // if (this.rowToFixScroll) {
      //   const { row, cache: previousSize } = this.rowToFixScroll;
      //   const actualSize = this.cache[row];
      //   if (actualSize && actualSize !== previousSize) {
      //     this.getScrollParent().scrollBy({
      //       top: -(
      //         (previousSize || this.props.itemSizeEstimator(row, {})) - actualSize
      //       )
      //     });
      //     this.rowToFixScroll = null;
      //   }
      // }
    }
    // shouldComponentUpdate() {
    //   if (this.dontUpdate) {
    //     this.dontUpdate = false;
    //     return false;
    //   }
    //   return true;
    // }

  }, {
    key: 'maybeSetState',
    value: function maybeSetState(b, cb) {
      if (isEqualSubset(this.state, b)) return cb();

      //TNR: extra code to 'fix' the scroll height when scrolling upwards
      if (this.state.from === b.from + 1) {
        this.rowToFixScroll = { row: b.from, cache: this.cache[b.from] };
      }
      this.setState(b, cb);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.updateFrame);
      this.scrollParent.removeEventListener('scroll', this.updateFrame, PASSIVE);
      this.scrollParent.removeEventListener('mousewheel', NOOP, PASSIVE);
    }
  }, {
    key: 'getOffset',
    value: function getOffset(el) {
      var axis = this.props.axis;

      var offset = el[CLIENT_START_KEYS[axis]] || 0;
      var offsetKey = OFFSET_START_KEYS[axis];
      do {
        offset += el[offsetKey] || 0;
      } while (el = el.offsetParent);
      return offset;
    }
  }, {
    key: 'getEl',
    value: function getEl() {
      return this.el || this.items;
    }
  }, {
    key: 'getScrollParent',
    value: function getScrollParent() {
      var _props = this.props,
          axis = _props.axis,
          scrollParentGetter = _props.scrollParentGetter;

      if (scrollParentGetter) return scrollParentGetter();
      var el = this.getEl();
      if (!el) return window;
      var overflowKey = OVERFLOW_KEYS[axis];
      while (el = el.parentElement) {
        switch (window.getComputedStyle(el)[overflowKey]) {
          case 'auto':
          case 'scroll':
          case 'overlay':
            return el;
        }
      }
      return window;
    }
  }, {
    key: 'getScrollPosition',
    value: function getScrollPosition() {
      var scrollParent = this.scrollParent;
      var axis = this.props.axis;

      var scrollKey = SCROLL_START_KEYS[axis];
      var actual = scrollParent === window ? // Firefox always returns document.body[scrollKey] as 0 and Chrome/Safari
      // always return document.documentElement[scrollKey] as 0, so take
      // whichever has a value.
      document.body[scrollKey] || document.documentElement[scrollKey] : scrollParent[scrollKey];
      var max = this.getScrollSize() - this.getViewportSize();
      var scroll = Math.max(0, Math.min(actual, max));
      var el = this.getEl();
      return this.getOffset(scrollParent) + scroll - this.getOffset(el);
    }
  }, {
    key: 'setScroll',
    value: function setScroll(offset) {
      var scrollParent = this.scrollParent;
      var axis = this.props.axis;

      offset += this.getOffset(this.getEl());
      if (scrollParent === window) return window.scrollTo(0, offset);

      offset -= this.getOffset(this.scrollParent);
      scrollParent[SCROLL_START_KEYS[axis]] = offset;
    }
  }, {
    key: 'getViewportSize',
    value: function getViewportSize() {
      var scrollParent = this.scrollParent;
      var axis = this.props.axis;

      return scrollParent === window ? window[INNER_SIZE_KEYS[axis]] : scrollParent[CLIENT_SIZE_KEYS[axis]];
    }
  }, {
    key: 'getScrollSize',
    value: function getScrollSize() {
      var scrollParent = this.scrollParent;
      var _document = document,
          body = _document.body,
          documentElement = _document.documentElement;

      var key = SCROLL_SIZE_KEYS[this.props.axis];
      return scrollParent === window ? Math.max(body[key], documentElement[key]) : scrollParent[key];
    }
  }, {
    key: 'hasDeterminateSize',
    value: function hasDeterminateSize() {
      var _props2 = this.props,
          itemSizeGetter = _props2.itemSizeGetter,
          type = _props2.type;

      return type === 'uniform' || itemSizeGetter;
    }
  }, {
    key: 'getStartAndEnd',
    value: function getStartAndEnd() {
      var threshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.threshold;

      var scroll = this.getScrollPosition();
      var start = Math.max(0, scroll - threshold);
      var end = scroll + this.getViewportSize() + threshold;
      if (this.hasDeterminateSize()) {
        end = Math.min(end, this.getSpaceBefore(this.props.length));
      }
      return { start: start, end: end };
    }
  }, {
    key: 'getItemSizeAndItemsPerRow',
    value: function getItemSizeAndItemsPerRow() {
      var _props3 = this.props,
          axis = _props3.axis,
          useStaticSize = _props3.useStaticSize;
      var _state = this.state,
          itemSize = _state.itemSize,
          itemsPerRow = _state.itemsPerRow;

      if (useStaticSize && itemSize && itemsPerRow) {
        return { itemSize: itemSize, itemsPerRow: itemsPerRow };
      }

      var itemEls = this.items.children;
      if (!itemEls.length) return {};

      var firstEl = itemEls[0];

      // Firefox has a problem where it will return a *slightly* (less than
      // thousandths of a pixel) different size for the same element between
      // renders. This can cause an infinite render loop, so only change the
      // itemSize when it is significantly different.
      var firstElSize = firstEl[OFFSET_SIZE_KEYS[axis]];
      var delta = Math.abs(firstElSize - itemSize);
      if (isNaN(delta) || delta >= 1) itemSize = firstElSize;

      if (!itemSize) return {};

      var startKey = OFFSET_START_KEYS[axis];
      var firstStart = firstEl[startKey];
      itemsPerRow = 1;
      for (var item = itemEls[itemsPerRow]; item && item[startKey] === firstStart; item = itemEls[itemsPerRow]) {
        ++itemsPerRow;
      }

      return { itemSize: itemSize, itemsPerRow: itemsPerRow };
    }
  }, {
    key: 'updateFrame',
    value: function updateFrame(cb) {
      this.updateScrollParent();
      if (typeof cb !== 'function') cb = NOOP;
      switch (this.props.type) {
        case 'simple':
          return this.updateSimpleFrame(cb);
        case 'variable':
          return this.updateVariableFrame(cb);
        case 'uniform':
          return this.updateUniformFrame(cb);
      }
    }
  }, {
    key: 'updateScrollParent',
    value: function updateScrollParent() {
      var prev = this.scrollParent;
      if (prev) {
        return; //https://github.com/coderiety/react-list/pull/196
      }
      this.scrollParent = this.getScrollParent();
      if (prev === this.scrollParent) return;
      if (prev) {
        prev.removeEventListener('scroll', this.updateFrame);
        prev.removeEventListener('mousewheel', NOOP);
      }
      this.scrollParent.addEventListener('scroll', this.updateFrame, PASSIVE);
      this.scrollParent.addEventListener('mousewheel', NOOP, PASSIVE);
    }
  }, {
    key: 'updateSimpleFrame',
    value: function updateSimpleFrame(cb) {
      var _getStartAndEnd = this.getStartAndEnd(),
          end = _getStartAndEnd.end;

      var itemEls = this.items.children;
      var elEnd = 0;

      if (itemEls.length) {
        var axis = this.props.axis;

        var firstItemEl = itemEls[0];
        var lastItemEl = itemEls[itemEls.length - 1];
        elEnd = this.getOffset(lastItemEl) + lastItemEl[OFFSET_SIZE_KEYS[axis]] - this.getOffset(firstItemEl);
      }

      if (elEnd > end) return cb();

      var _props4 = this.props,
          pageSize = _props4.pageSize,
          length = _props4.length;

      var size = Math.min(this.state.size + pageSize, length);
      this.maybeSetState({ size: size }, cb);
    }
  }, {
    key: 'updateVariableFrame',
    value: function updateVariableFrame(cb) {
      if (!this.props.itemSizeGetter) this.cacheSizes();

      var _getStartAndEnd2 = this.getStartAndEnd(),
          start = _getStartAndEnd2.start,
          end = _getStartAndEnd2.end;

      var _props5 = this.props,
          length = _props5.length,
          pageSize = _props5.pageSize;

      var space = 0;
      var from = 0;
      var size = 0;
      var maxFrom = length - 1;

      while (from < maxFrom) {
        var itemSize = this.getSizeOfItem(from);
        if (itemSize == null || space + itemSize > start) break;
        space += itemSize;
        ++from;
      }

      var maxSize = length - from;

      while (size < maxSize && space < end) {
        var _itemSize = this.getSizeOfItem(from + size);
        if (_itemSize == null) {
          size = Math.min(size + pageSize, maxSize);
          break;
        }
        space += _itemSize;
        ++size;
      }
      this.maybeSetState({ from: from, size: size }, cb);
    }
  }, {
    key: 'updateUniformFrame',
    value: function updateUniformFrame(cb) {
      var _getItemSizeAndItemsP = this.getItemSizeAndItemsPerRow(),
          itemSize = _getItemSizeAndItemsP.itemSize,
          itemsPerRow = _getItemSizeAndItemsP.itemsPerRow;

      if (!itemSize || !itemsPerRow) return cb();

      var _getStartAndEnd3 = this.getStartAndEnd(),
          start = _getStartAndEnd3.start,
          end = _getStartAndEnd3.end;

      var _constrain = this.constrain(Math.floor(start / itemSize) * itemsPerRow, (Math.ceil((end - start) / itemSize) + 1) * itemsPerRow, itemsPerRow, this.props),
          from = _constrain.from,
          size = _constrain.size;

      return this.maybeSetState({ itemsPerRow: itemsPerRow, from: from, itemSize: itemSize, size: size }, cb);
    }
  }, {
    key: 'getSpaceBefore',
    value: function getSpaceBefore(index) {
      var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (cache[index] != null) return cache[index];

      // Try the static itemSize.
      var _state2 = this.state,
          itemSize = _state2.itemSize,
          itemsPerRow = _state2.itemsPerRow;

      if (itemSize) {
        return cache[index] = Math.floor(index / itemsPerRow) * itemSize;
      }

      // Find the closest space to index there is a cached value for.
      var from = index;
      while (from > 0 && cache[--from] == null) {}

      // Finally, accumulate sizes of items from - index.
      var space = cache[from] || 0;
      for (var i = from; i < index; ++i) {
        cache[i] = space;
        var _itemSize2 = this.getSizeOfItem(i);
        if (_itemSize2 == null) break;
        space += _itemSize2;
      }

      return cache[index] = space;
    }
  }, {
    key: 'cacheSizes',
    value: function cacheSizes() {
      var cache = this.cache;
      var from = this.state.from;

      if (!this.items) return;
      var itemEls = this.items.children;
      var sizeKey = OFFSET_SIZE_KEYS[this.props.axis];
      for (var i = 0, l = itemEls.length; i < l; ++i) {
        cache[from + i] = itemEls[i][sizeKey];
      }
    }
  }, {
    key: 'getSizeOfItem',
    value: function getSizeOfItem(index) {
      var cache = this.cache,
          items = this.items;
      var _props6 = this.props,
          axis = _props6.axis,
          itemSizeGetter = _props6.itemSizeGetter,
          itemSizeEstimator = _props6.itemSizeEstimator,
          type = _props6.type;
      var _state3 = this.state,
          from = _state3.from,
          itemSize = _state3.itemSize,
          size = _state3.size;

      // Try the static itemSize.

      if (itemSize) return itemSize;

      // Try the itemSizeGetter.
      if (itemSizeGetter) return itemSizeGetter(index);

      // Try the cache.
      if (index in cache) return cache[index];

      // Try the DOM.
      if (type === 'simple' && index >= from && index < from + size && items) {
        var itemEl = items.children[index - from];
        if (itemEl) return itemEl[OFFSET_SIZE_KEYS[axis]];
      }

      // Try the itemSizeEstimator.
      if (itemSizeEstimator) return itemSizeEstimator(index, cache);
    }
  }, {
    key: 'constrain',
    value: function constrain(from, size, itemsPerRow, _ref) {
      var length = _ref.length,
          minSize = _ref.minSize,
          type = _ref.type;

      size = Math.max(size, minSize);
      var mod = size % itemsPerRow;
      if (mod) size += itemsPerRow - mod;
      if (size > length) size = length;
      from = type === 'simple' || !from ? 0 : Math.max(Math.min(from, length - size), 0);

      if (mod = from % itemsPerRow) {
        from -= mod;
        size += mod;
      }

      return { from: from, size: size };
    }
  }, {
    key: 'scrollTo',
    value: function scrollTo(index) {
      if (index != null) this.setScroll(this.getSpaceBefore(index) - 100);
    }
  }, {
    key: 'scrollAround',
    value: function scrollAround(index) {
      var current = this.getScrollPosition();
      var bottom = this.getSpaceBefore(index);
      var top = bottom - this.getViewportSize() + this.getSizeOfItem(index);
      var min = Math.min(top, bottom);
      var max = Math.max(top, bottom);
      if (current <= min) return this.setScroll(min - this.getViewportSize());
      if (current > max) {
        return this.setScroll(max - this.getViewportSize() - 100);
      }
    }
  }, {
    key: 'getVisibleRange',
    value: function getVisibleRange() {
      var _state4 = this.state,
          from = _state4.from,
          size = _state4.size;

      var _getStartAndEnd4 = this.getStartAndEnd(0),
          start = _getStartAndEnd4.start,
          end = _getStartAndEnd4.end;

      var cache = {};
      var first = void 0,
          last = void 0;
      for (var i = from; i < from + size; ++i) {
        var itemStart = this.getSpaceBefore(i, cache);
        var itemEnd = itemStart + this.getSizeOfItem(i);
        if (first == null && itemEnd > start) first = i;
        if (first != null && itemStart < end) last = i;
      }
      return [first, last];
    }
    //this can be used as a static method via the react list ref

  }, {
    key: 'getFractionalVisibleRange',
    value: function getFractionalVisibleRange() {
      var _state5 = this.state,
          from = _state5.from,
          size = _state5.size;

      var _getStartAndEnd5 = this.getStartAndEnd(0),
          start = _getStartAndEnd5.start,
          end = _getStartAndEnd5.end;

      var cache = {};
      var first = void 0,
          last = void 0;

      for (var i = from; i < from + size; ++i) {
        var itemStart = this.getSpaceBefore(i, cache);
        var itemEnd = itemStart + this.getSizeOfItem(i);
        if (first == null && itemEnd > start) {
          first = i + 1 - (itemEnd - start) / (itemEnd - itemStart);
        }
        if (first != null && itemStart < end) {
          last = i - (itemEnd - end) / (itemEnd - itemStart);
        }
      }
      return [first, last];
    }
  }, {
    key: 'renderItems',
    value: function renderItems() {
      var _this3 = this;

      var _props7 = this.props,
          itemRenderer = _props7.itemRenderer,
          itemsRenderer = _props7.itemsRenderer;
      var _state6 = this.state,
          from = _state6.from,
          size = _state6.size;

      var items = [];
      for (var i = 0; i < size; ++i) {
        items.push(itemRenderer(from + i, i));
      }return itemsRenderer(items, function (c) {
        return _this3.items = c;
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props8 = this.props,
          axis = _props8.axis,
          length = _props8.length,
          type = _props8.type;
      var _state7 = this.state,
          from = _state7.from,
          itemsPerRow = _state7.itemsPerRow;

      var items = this.renderItems();
      if (type === 'simple') return items;

      var style = { position: 'relative' };
      var cache = {};
      var bottom = Math.ceil(length / itemsPerRow) * itemsPerRow;
      var size = this.getSpaceBefore(bottom, cache);
      if (size) {
        style[SIZE_KEYS[axis]] = size;
        if (axis === 'x') style.overflowX = 'hidden';
      }
      var offset = this.getSpaceBefore(from, cache);
      var x = axis === 'x' ? offset : 0;
      var y = axis === 'y' ? offset : 0;
      var listStyle = {
        //tnr trying out: https://github.com/coderiety/react-list/pull/154
        position: 'relative',
        top: y,
        left: x
      };
      return _react2.default.createElement(
        'div',
        {
          style: style,
          ref: function ref(c) {
            if (c) _this4.el = c;
          }
        },
        _react2.default.createElement(
          'div',
          { style: listStyle },
          items
        )
      );
    }
  }]);

  return ReactList;
}(_react2.default.Component);

ReactList.displayName = 'ReactList';
ReactList.propTypes = {
  axis: _propTypes2.default.oneOf(['x', 'y']),
  initialIndex: _propTypes2.default.number,
  itemRenderer: _propTypes2.default.func,
  itemSizeEstimator: _propTypes2.default.func,
  itemSizeGetter: _propTypes2.default.func,
  itemsRenderer: _propTypes2.default.func,
  length: _propTypes2.default.number,
  minSize: _propTypes2.default.number,
  pageSize: _propTypes2.default.number,
  scrollParentGetter: _propTypes2.default.func,
  threshold: _propTypes2.default.number,
  type: _propTypes2.default.oneOf(['simple', 'variable', 'uniform']),
  useStaticSize: _propTypes2.default.bool,
  useTranslate3d: _propTypes2.default.bool
};
ReactList.defaultProps = {
  axis: 'y',
  itemRenderer: function itemRenderer(index, key) {
    return _react2.default.createElement(
      'div',
      { key: key },
      index
    );
  },
  itemsRenderer: function itemsRenderer(items, ref) {
    return _react2.default.createElement(
      'div',
      { ref: ref },
      items
    );
  },
  length: 0,
  minSize: 1,
  pageSize: 10,
  threshold: 100,
  type: 'simple',
  useStaticSize: false,
  useTranslate3d: false
};
exports.default = ReactList;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdExpc3QuanMiXSwibmFtZXMiOlsiQ0xJRU5UX1NJWkVfS0VZUyIsIngiLCJ5IiwiQ0xJRU5UX1NUQVJUX0tFWVMiLCJJTk5FUl9TSVpFX0tFWVMiLCJPRkZTRVRfU0laRV9LRVlTIiwiT0ZGU0VUX1NUQVJUX0tFWVMiLCJPVkVSRkxPV19LRVlTIiwiU0NST0xMX1NJWkVfS0VZUyIsIlNDUk9MTF9TVEFSVF9LRVlTIiwiU0laRV9LRVlTIiwiTk9PUCIsIlBBU1NJVkUiLCJ3aW5kb3ciLCJoYXNTdXBwb3J0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJlIiwiVU5TVEFCTEVfTUVTU0FHRSIsIk1BWF9TWU5DX1VQREFURVMiLCJpc0VxdWFsU3Vic2V0IiwiYSIsImIiLCJrZXkiLCJSZWFjdExpc3QiLCJwcm9wcyIsImluaXRpYWxJbmRleCIsIml0ZW1zUGVyUm93IiwiY29uc3RyYWluIiwiZnJvbSIsInNpemUiLCJzdGF0ZSIsImNhY2hlIiwicHJldlByZXZTdGF0ZSIsInVuc3RhYmxlIiwidXBkYXRlQ291bnRlciIsInVwZGF0ZUZyYW1lIiwiYmluZCIsInNjcm9sbFRvIiwiY29uc29sZSIsImVycm9yIiwidXBkYXRlQ291bnRlclRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJjYiIsInJvd1RvRml4U2Nyb2xsIiwicm93Iiwic2V0U3RhdGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2Nyb2xsUGFyZW50IiwiZWwiLCJheGlzIiwib2Zmc2V0Iiwib2Zmc2V0S2V5Iiwib2Zmc2V0UGFyZW50IiwiaXRlbXMiLCJzY3JvbGxQYXJlbnRHZXR0ZXIiLCJnZXRFbCIsIm92ZXJmbG93S2V5IiwicGFyZW50RWxlbWVudCIsImdldENvbXB1dGVkU3R5bGUiLCJzY3JvbGxLZXkiLCJhY3R1YWwiLCJib2R5IiwiZG9jdW1lbnRFbGVtZW50IiwibWF4IiwiZ2V0U2Nyb2xsU2l6ZSIsImdldFZpZXdwb3J0U2l6ZSIsInNjcm9sbCIsIk1hdGgiLCJtaW4iLCJnZXRPZmZzZXQiLCJpdGVtU2l6ZUdldHRlciIsInR5cGUiLCJ0aHJlc2hvbGQiLCJnZXRTY3JvbGxQb3NpdGlvbiIsInN0YXJ0IiwiZW5kIiwiaGFzRGV0ZXJtaW5hdGVTaXplIiwiZ2V0U3BhY2VCZWZvcmUiLCJsZW5ndGgiLCJ1c2VTdGF0aWNTaXplIiwiaXRlbVNpemUiLCJpdGVtRWxzIiwiY2hpbGRyZW4iLCJmaXJzdEVsIiwiZmlyc3RFbFNpemUiLCJkZWx0YSIsImFicyIsImlzTmFOIiwic3RhcnRLZXkiLCJmaXJzdFN0YXJ0IiwiaXRlbSIsInVwZGF0ZVNjcm9sbFBhcmVudCIsInVwZGF0ZVNpbXBsZUZyYW1lIiwidXBkYXRlVmFyaWFibGVGcmFtZSIsInVwZGF0ZVVuaWZvcm1GcmFtZSIsInByZXYiLCJnZXRTY3JvbGxQYXJlbnQiLCJnZXRTdGFydEFuZEVuZCIsImVsRW5kIiwiZmlyc3RJdGVtRWwiLCJsYXN0SXRlbUVsIiwicGFnZVNpemUiLCJtYXliZVNldFN0YXRlIiwiY2FjaGVTaXplcyIsInNwYWNlIiwibWF4RnJvbSIsImdldFNpemVPZkl0ZW0iLCJtYXhTaXplIiwiZ2V0SXRlbVNpemVBbmRJdGVtc1BlclJvdyIsImZsb29yIiwiY2VpbCIsImluZGV4IiwiaSIsInNpemVLZXkiLCJsIiwiaXRlbVNpemVFc3RpbWF0b3IiLCJpdGVtRWwiLCJtaW5TaXplIiwibW9kIiwic2V0U2Nyb2xsIiwiY3VycmVudCIsImJvdHRvbSIsInRvcCIsImZpcnN0IiwibGFzdCIsIml0ZW1TdGFydCIsIml0ZW1FbmQiLCJpdGVtUmVuZGVyZXIiLCJpdGVtc1JlbmRlcmVyIiwicHVzaCIsImMiLCJyZW5kZXJJdGVtcyIsInN0eWxlIiwicG9zaXRpb24iLCJvdmVyZmxvd1giLCJsaXN0U3R5bGUiLCJsZWZ0IiwiUmVhY3QiLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIm9uZU9mIiwibnVtYmVy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YWJsZSBuby1lbXB0eSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4vKiBlc2xpbnQtZGlzYWJsZSBkZWZhdWx0LWNhc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIGRlZmF1bHQtY2FzZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbi8vIGltcG9ydCBtb2R1bGUgZnJvbSAnbW9kdWxlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBDTElFTlRfU0laRV9LRVlTID0geyB4OiAnY2xpZW50V2lkdGgnLCB5OiAnY2xpZW50SGVpZ2h0JyB9O1xuY29uc3QgQ0xJRU5UX1NUQVJUX0tFWVMgPSB7IHg6ICdjbGllbnRUb3AnLCB5OiAnY2xpZW50TGVmdCcgfTtcbmNvbnN0IElOTkVSX1NJWkVfS0VZUyA9IHsgeDogJ2lubmVyV2lkdGgnLCB5OiAnaW5uZXJIZWlnaHQnIH07XG5jb25zdCBPRkZTRVRfU0laRV9LRVlTID0geyB4OiAnb2Zmc2V0V2lkdGgnLCB5OiAnb2Zmc2V0SGVpZ2h0JyB9O1xuY29uc3QgT0ZGU0VUX1NUQVJUX0tFWVMgPSB7IHg6ICdvZmZzZXRMZWZ0JywgeTogJ29mZnNldFRvcCcgfTtcbmNvbnN0IE9WRVJGTE9XX0tFWVMgPSB7IHg6ICdvdmVyZmxvd1gnLCB5OiAnb3ZlcmZsb3dZJyB9O1xuY29uc3QgU0NST0xMX1NJWkVfS0VZUyA9IHsgeDogJ3Njcm9sbFdpZHRoJywgeTogJ3Njcm9sbEhlaWdodCcgfTtcbmNvbnN0IFNDUk9MTF9TVEFSVF9LRVlTID0geyB4OiAnc2Nyb2xsTGVmdCcsIHk6ICdzY3JvbGxUb3AnIH07XG5jb25zdCBTSVpFX0tFWVMgPSB7IHg6ICdtaW5XaWR0aCcsIHk6ICdtaW5IZWlnaHQnIH07XG5cbmNvbnN0IE5PT1AgPSAoKSA9PiB7fTtcblxuLy8gSWYgYSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IHRvXG4vLyBhZGQvcmVtb3ZlRXZlbnRMaXN0ZW5lciwgd2UgbmVlZCB0byBjaGVjaywgb3RoZXJ3aXNlIHdlIHdpbGxcbi8vIGFjY2lkZW50YWxseSBzZXQgYGNhcHR1cmVgIHdpdGggYSB0cnV0aHkgdmFsdWUuXG5jb25zdCBQQVNTSVZFID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG4gIGxldCBoYXNTdXBwb3J0ID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIE5PT1AsIHtcbiAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICBoYXNTdXBwb3J0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gbm9vcFxuICB9XG4gIHJldHVybiBoYXNTdXBwb3J0O1xufSkoKVxuICA/IHsgcGFzc2l2ZTogdHJ1ZSB9XG4gIDogZmFsc2U7XG5cbmNvbnN0IFVOU1RBQkxFX01FU1NBR0UgPSAnUmVhY3RMaXN0IGZhaWxlZCB0byByZWFjaCBhIHN0YWJsZSBzdGF0ZS4nO1xuY29uc3QgTUFYX1NZTkNfVVBEQVRFUyA9IDEwMDtcblxuY29uc3QgaXNFcXVhbFN1YnNldCA9IChhLCBiKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIGIpIGlmIChhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhY3RMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgc3RhdGljIGRpc3BsYXlOYW1lID0gJ1JlYWN0TGlzdCc7XG5cbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBheGlzOiBQcm9wVHlwZXMub25lT2YoWyd4JywgJ3knXSksXG4gICAgaW5pdGlhbEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGl0ZW1SZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaXRlbVNpemVFc3RpbWF0b3I6IFByb3BUeXBlcy5mdW5jLFxuICAgIGl0ZW1TaXplR2V0dGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBpdGVtc1JlbmRlcmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBsZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbWluU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBwYWdlU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBzY3JvbGxQYXJlbnRHZXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIHRocmVzaG9sZDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydzaW1wbGUnLCAndmFyaWFibGUnLCAndW5pZm9ybSddKSxcbiAgICB1c2VTdGF0aWNTaXplOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB1c2VUcmFuc2xhdGUzZDogUHJvcFR5cGVzLmJvb2xcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGF4aXM6ICd5JyxcbiAgICBpdGVtUmVuZGVyZXI6IChpbmRleCwga2V5KSA9PiA8ZGl2IGtleT17a2V5fT57aW5kZXh9PC9kaXY+LFxuICAgIGl0ZW1zUmVuZGVyZXI6IChpdGVtcywgcmVmKSA9PiA8ZGl2IHJlZj17cmVmfT57aXRlbXN9PC9kaXY+LFxuICAgIGxlbmd0aDogMCxcbiAgICBtaW5TaXplOiAxLFxuICAgIHBhZ2VTaXplOiAxMCxcbiAgICB0aHJlc2hvbGQ6IDEwMCxcbiAgICB0eXBlOiAnc2ltcGxlJyxcbiAgICB1c2VTdGF0aWNTaXplOiBmYWxzZSxcbiAgICB1c2VUcmFuc2xhdGUzZDogZmFsc2VcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBjb25zdCB7IGluaXRpYWxJbmRleCB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXRlbXNQZXJSb3cgPSAxO1xuICAgIGNvbnN0IHsgZnJvbSwgc2l6ZSB9ID0gdGhpcy5jb25zdHJhaW4oaW5pdGlhbEluZGV4LCAwLCBpdGVtc1BlclJvdywgcHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7IGZyb20sIHNpemUsIGl0ZW1zUGVyUm93IH07XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIHRoaXMucHJldlByZXZTdGF0ZSA9IHt9O1xuICAgIHRoaXMudW5zdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZUNvdW50ZXIgPSAwO1xuICB9XG5cbiAgLy90bnI6IGNvbW1lbnRpbmcgdGhpcyBvdXQuLiBub3Qgc3VyZSBpZiBpdCBpcyBhY3R1YWxseSBuZWVkZWRcbiAgLy8gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gIC8vICAgbGV0IHsgZnJvbSwgc2l6ZSwgaXRlbXNQZXJSb3cgfSA9IHRoaXMuc3RhdGU7XG4gIC8vICAgaWYgKG5leHRQcm9wcy5jbGVhckNhY2hlKSB0aGlzLmNhY2hlID0ge307XG4gIC8vICAgdGhpcy5tYXliZVNldFN0YXRlKFxuICAvLyAgICAgdGhpcy5jb25zdHJhaW4oZnJvbSwgc2l6ZSwgaXRlbXNQZXJSb3csIG5leHRQcm9wcyksXG4gIC8vICAgICBOT09QXG4gIC8vICAgKTtcbiAgLy8gfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudXBkYXRlRnJhbWUgPSB0aGlzLnVwZGF0ZUZyYW1lLmJpbmQodGhpcyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMudXBkYXRlRnJhbWUpO1xuICAgIHRoaXMudXBkYXRlRnJhbWUodGhpcy5zY3JvbGxUby5iaW5kKHRoaXMsIHRoaXMucHJvcHMuaW5pdGlhbEluZGV4KSk7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgLy8gSWYgdGhlIGxpc3QgaGFzIHJlYWNoZWQgYW4gdW5zdGFibGUgc3RhdGUsIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cbiAgICBpZiAodGhpcy51bnN0YWJsZSkgcmV0dXJuO1xuXG4gICAgaWYgKCsrdGhpcy51cGRhdGVDb3VudGVyID4gTUFYX1NZTkNfVVBEQVRFUykge1xuICAgICAgdGhpcy51bnN0YWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihVTlNUQUJMRV9NRVNTQUdFKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudXBkYXRlQ291bnRlclRpbWVvdXRJZCkge1xuICAgICAgdGhpcy51cGRhdGVDb3VudGVyVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlQ291bnRlciA9IDA7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVwZGF0ZUNvdW50ZXJUaW1lb3V0SWQ7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgLy8gdGhpcy5kb250VXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZUZyYW1lKCk7XG5cbiAgICAvL1ROUjogZXh0cmEgY29kZSB0byAnZml4JyB0aGUgc2Nyb2xsIGhlaWdodCB3aGVuIHNjcm9sbGluZyB1cHdhcmRzXG4gICAgLy90bnIgY29tbWVudGluZyB0aGlzIG91dCBiZWNhdXNlIHdlIGFyZSBub3cgZG9pbmcgYSBiZXR0ZXIgam9iIG9mIGNhbGN1bGF0aW5nIHJvdyBoZWlnaHRzXG4gICAgLy8gaWYgKHRoaXMucm93VG9GaXhTY3JvbGwpIHtcbiAgICAvLyAgIGNvbnN0IHsgcm93LCBjYWNoZTogcHJldmlvdXNTaXplIH0gPSB0aGlzLnJvd1RvRml4U2Nyb2xsO1xuICAgIC8vICAgY29uc3QgYWN0dWFsU2l6ZSA9IHRoaXMuY2FjaGVbcm93XTtcbiAgICAvLyAgIGlmIChhY3R1YWxTaXplICYmIGFjdHVhbFNpemUgIT09IHByZXZpb3VzU2l6ZSkge1xuICAgIC8vICAgICB0aGlzLmdldFNjcm9sbFBhcmVudCgpLnNjcm9sbEJ5KHtcbiAgICAvLyAgICAgICB0b3A6IC0oXG4gICAgLy8gICAgICAgICAocHJldmlvdXNTaXplIHx8IHRoaXMucHJvcHMuaXRlbVNpemVFc3RpbWF0b3Iocm93LCB7fSkpIC0gYWN0dWFsU2l6ZVxuICAgIC8vICAgICAgIClcbiAgICAvLyAgICAgfSk7XG4gICAgLy8gICAgIHRoaXMucm93VG9GaXhTY3JvbGwgPSBudWxsO1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgfVxuICAvLyBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG4gIC8vICAgaWYgKHRoaXMuZG9udFVwZGF0ZSkge1xuICAvLyAgICAgdGhpcy5kb250VXBkYXRlID0gZmFsc2U7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiB0cnVlO1xuICAvLyB9XG4gIG1heWJlU2V0U3RhdGUoYiwgY2IpIHtcbiAgICBpZiAoaXNFcXVhbFN1YnNldCh0aGlzLnN0YXRlLCBiKSkgcmV0dXJuIGNiKCk7XG5cbiAgICAvL1ROUjogZXh0cmEgY29kZSB0byAnZml4JyB0aGUgc2Nyb2xsIGhlaWdodCB3aGVuIHNjcm9sbGluZyB1cHdhcmRzXG4gICAgaWYgKHRoaXMuc3RhdGUuZnJvbSA9PT0gYi5mcm9tICsgMSkge1xuICAgICAgdGhpcy5yb3dUb0ZpeFNjcm9sbCA9IHsgcm93OiBiLmZyb20sIGNhY2hlOiB0aGlzLmNhY2hlW2IuZnJvbV0gfTtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZShiLCBjYik7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy51cGRhdGVGcmFtZSk7XG4gICAgdGhpcy5zY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy51cGRhdGVGcmFtZSwgUEFTU0lWRSk7XG4gICAgdGhpcy5zY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIE5PT1AsIFBBU1NJVkUpO1xuICB9XG5cbiAgZ2V0T2Zmc2V0KGVsKSB7XG4gICAgY29uc3QgeyBheGlzIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBvZmZzZXQgPSBlbFtDTElFTlRfU1RBUlRfS0VZU1theGlzXV0gfHwgMDtcbiAgICBjb25zdCBvZmZzZXRLZXkgPSBPRkZTRVRfU1RBUlRfS0VZU1theGlzXTtcbiAgICBkbyBvZmZzZXQgKz0gZWxbb2Zmc2V0S2V5XSB8fCAwO1xuICAgIHdoaWxlICgoZWwgPSBlbC5vZmZzZXRQYXJlbnQpKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgZ2V0RWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwgfHwgdGhpcy5pdGVtcztcbiAgfVxuXG4gIGdldFNjcm9sbFBhcmVudCgpIHtcbiAgICBjb25zdCB7IGF4aXMsIHNjcm9sbFBhcmVudEdldHRlciB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoc2Nyb2xsUGFyZW50R2V0dGVyKSByZXR1cm4gc2Nyb2xsUGFyZW50R2V0dGVyKCk7XG4gICAgbGV0IGVsID0gdGhpcy5nZXRFbCgpO1xuICAgIGlmICghZWwpIHJldHVybiB3aW5kb3c7XG4gICAgY29uc3Qgb3ZlcmZsb3dLZXkgPSBPVkVSRkxPV19LRVlTW2F4aXNdO1xuICAgIHdoaWxlICgoZWwgPSBlbC5wYXJlbnRFbGVtZW50KSkge1xuICAgICAgc3dpdGNoICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbClbb3ZlcmZsb3dLZXldKSB7XG4gICAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgICBjYXNlICdzY3JvbGwnOlxuICAgICAgICBjYXNlICdvdmVybGF5JzpcbiAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBnZXRTY3JvbGxQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7IHNjcm9sbFBhcmVudCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGF4aXMgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgc2Nyb2xsS2V5ID0gU0NST0xMX1NUQVJUX0tFWVNbYXhpc107XG4gICAgY29uc3QgYWN0dWFsID1cbiAgICAgIHNjcm9sbFBhcmVudCA9PT0gd2luZG93XG4gICAgICAgID8gLy8gRmlyZWZveCBhbHdheXMgcmV0dXJucyBkb2N1bWVudC5ib2R5W3Njcm9sbEtleV0gYXMgMCBhbmQgQ2hyb21lL1NhZmFyaVxuICAgICAgICAgIC8vIGFsd2F5cyByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W3Njcm9sbEtleV0gYXMgMCwgc28gdGFrZVxuICAgICAgICAgIC8vIHdoaWNoZXZlciBoYXMgYSB2YWx1ZS5cbiAgICAgICAgICBkb2N1bWVudC5ib2R5W3Njcm9sbEtleV0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W3Njcm9sbEtleV1cbiAgICAgICAgOiBzY3JvbGxQYXJlbnRbc2Nyb2xsS2V5XTtcbiAgICBjb25zdCBtYXggPSB0aGlzLmdldFNjcm9sbFNpemUoKSAtIHRoaXMuZ2V0Vmlld3BvcnRTaXplKCk7XG4gICAgY29uc3Qgc2Nyb2xsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYWN0dWFsLCBtYXgpKTtcbiAgICBjb25zdCBlbCA9IHRoaXMuZ2V0RWwoKTtcbiAgICByZXR1cm4gdGhpcy5nZXRPZmZzZXQoc2Nyb2xsUGFyZW50KSArIHNjcm9sbCAtIHRoaXMuZ2V0T2Zmc2V0KGVsKTtcbiAgfVxuXG4gIHNldFNjcm9sbChvZmZzZXQpIHtcbiAgICBjb25zdCB7IHNjcm9sbFBhcmVudCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGF4aXMgfSA9IHRoaXMucHJvcHM7XG4gICAgb2Zmc2V0ICs9IHRoaXMuZ2V0T2Zmc2V0KHRoaXMuZ2V0RWwoKSk7XG4gICAgaWYgKHNjcm9sbFBhcmVudCA9PT0gd2luZG93KSByZXR1cm4gd2luZG93LnNjcm9sbFRvKDAsIG9mZnNldCk7XG5cbiAgICBvZmZzZXQgLT0gdGhpcy5nZXRPZmZzZXQodGhpcy5zY3JvbGxQYXJlbnQpO1xuICAgIHNjcm9sbFBhcmVudFtTQ1JPTExfU1RBUlRfS0VZU1theGlzXV0gPSBvZmZzZXQ7XG4gIH1cblxuICBnZXRWaWV3cG9ydFNpemUoKSB7XG4gICAgY29uc3QgeyBzY3JvbGxQYXJlbnQgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBheGlzIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiBzY3JvbGxQYXJlbnQgPT09IHdpbmRvd1xuICAgICAgPyB3aW5kb3dbSU5ORVJfU0laRV9LRVlTW2F4aXNdXVxuICAgICAgOiBzY3JvbGxQYXJlbnRbQ0xJRU5UX1NJWkVfS0VZU1theGlzXV07XG4gIH1cblxuICBnZXRTY3JvbGxTaXplKCkge1xuICAgIGNvbnN0IHsgc2Nyb2xsUGFyZW50IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYm9keSwgZG9jdW1lbnRFbGVtZW50IH0gPSBkb2N1bWVudDtcbiAgICBjb25zdCBrZXkgPSBTQ1JPTExfU0laRV9LRVlTW3RoaXMucHJvcHMuYXhpc107XG4gICAgcmV0dXJuIHNjcm9sbFBhcmVudCA9PT0gd2luZG93XG4gICAgICA/IE1hdGgubWF4KGJvZHlba2V5XSwgZG9jdW1lbnRFbGVtZW50W2tleV0pXG4gICAgICA6IHNjcm9sbFBhcmVudFtrZXldO1xuICB9XG5cbiAgaGFzRGV0ZXJtaW5hdGVTaXplKCkge1xuICAgIGNvbnN0IHsgaXRlbVNpemVHZXR0ZXIsIHR5cGUgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIHR5cGUgPT09ICd1bmlmb3JtJyB8fCBpdGVtU2l6ZUdldHRlcjtcbiAgfVxuXG4gIGdldFN0YXJ0QW5kRW5kKHRocmVzaG9sZCA9IHRoaXMucHJvcHMudGhyZXNob2xkKSB7XG4gICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5nZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgc2Nyb2xsIC0gdGhyZXNob2xkKTtcbiAgICBsZXQgZW5kID0gc2Nyb2xsICsgdGhpcy5nZXRWaWV3cG9ydFNpemUoKSArIHRocmVzaG9sZDtcbiAgICBpZiAodGhpcy5oYXNEZXRlcm1pbmF0ZVNpemUoKSkge1xuICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCB0aGlzLmdldFNwYWNlQmVmb3JlKHRoaXMucHJvcHMubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgfVxuXG4gIGdldEl0ZW1TaXplQW5kSXRlbXNQZXJSb3coKSB7XG4gICAgY29uc3QgeyBheGlzLCB1c2VTdGF0aWNTaXplIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCB7IGl0ZW1TaXplLCBpdGVtc1BlclJvdyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodXNlU3RhdGljU2l6ZSAmJiBpdGVtU2l6ZSAmJiBpdGVtc1BlclJvdykge1xuICAgICAgcmV0dXJuIHsgaXRlbVNpemUsIGl0ZW1zUGVyUm93IH07XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbUVscyA9IHRoaXMuaXRlbXMuY2hpbGRyZW47XG4gICAgaWYgKCFpdGVtRWxzLmxlbmd0aCkgcmV0dXJuIHt9O1xuXG4gICAgY29uc3QgZmlyc3RFbCA9IGl0ZW1FbHNbMF07XG5cbiAgICAvLyBGaXJlZm94IGhhcyBhIHByb2JsZW0gd2hlcmUgaXQgd2lsbCByZXR1cm4gYSAqc2xpZ2h0bHkqIChsZXNzIHRoYW5cbiAgICAvLyB0aG91c2FuZHRocyBvZiBhIHBpeGVsKSBkaWZmZXJlbnQgc2l6ZSBmb3IgdGhlIHNhbWUgZWxlbWVudCBiZXR3ZWVuXG4gICAgLy8gcmVuZGVycy4gVGhpcyBjYW4gY2F1c2UgYW4gaW5maW5pdGUgcmVuZGVyIGxvb3AsIHNvIG9ubHkgY2hhbmdlIHRoZVxuICAgIC8vIGl0ZW1TaXplIHdoZW4gaXQgaXMgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQuXG4gICAgY29uc3QgZmlyc3RFbFNpemUgPSBmaXJzdEVsW09GRlNFVF9TSVpFX0tFWVNbYXhpc11dO1xuICAgIGNvbnN0IGRlbHRhID0gTWF0aC5hYnMoZmlyc3RFbFNpemUgLSBpdGVtU2l6ZSk7XG4gICAgaWYgKGlzTmFOKGRlbHRhKSB8fCBkZWx0YSA+PSAxKSBpdGVtU2l6ZSA9IGZpcnN0RWxTaXplO1xuXG4gICAgaWYgKCFpdGVtU2l6ZSkgcmV0dXJuIHt9O1xuXG4gICAgY29uc3Qgc3RhcnRLZXkgPSBPRkZTRVRfU1RBUlRfS0VZU1theGlzXTtcbiAgICBjb25zdCBmaXJzdFN0YXJ0ID0gZmlyc3RFbFtzdGFydEtleV07XG4gICAgaXRlbXNQZXJSb3cgPSAxO1xuICAgIGZvciAoXG4gICAgICBsZXQgaXRlbSA9IGl0ZW1FbHNbaXRlbXNQZXJSb3ddO1xuICAgICAgaXRlbSAmJiBpdGVtW3N0YXJ0S2V5XSA9PT0gZmlyc3RTdGFydDtcbiAgICAgIGl0ZW0gPSBpdGVtRWxzW2l0ZW1zUGVyUm93XVxuICAgICkge1xuICAgICAgKytpdGVtc1BlclJvdztcbiAgICB9XG5cbiAgICByZXR1cm4geyBpdGVtU2l6ZSwgaXRlbXNQZXJSb3cgfTtcbiAgfVxuXG4gIHVwZGF0ZUZyYW1lKGNiKSB7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxQYXJlbnQoKTtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IE5PT1A7XG4gICAgc3dpdGNoICh0aGlzLnByb3BzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3NpbXBsZSc6XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVNpbXBsZUZyYW1lKGNiKTtcbiAgICAgIGNhc2UgJ3ZhcmlhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlVmFyaWFibGVGcmFtZShjYik7XG4gICAgICBjYXNlICd1bmlmb3JtJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlVW5pZm9ybUZyYW1lKGNiKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVTY3JvbGxQYXJlbnQoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMuc2Nyb2xsUGFyZW50O1xuICAgIGlmIChwcmV2KSB7XG4gICAgICByZXR1cm47IC8vaHR0cHM6Ly9naXRodWIuY29tL2NvZGVyaWV0eS9yZWFjdC1saXN0L3B1bGwvMTk2XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsUGFyZW50ID0gdGhpcy5nZXRTY3JvbGxQYXJlbnQoKTtcbiAgICBpZiAocHJldiA9PT0gdGhpcy5zY3JvbGxQYXJlbnQpIHJldHVybjtcbiAgICBpZiAocHJldikge1xuICAgICAgcHJldi5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnVwZGF0ZUZyYW1lKTtcbiAgICAgIHByZXYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIE5PT1ApO1xuICAgIH1cbiAgICB0aGlzLnNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnVwZGF0ZUZyYW1lLCBQQVNTSVZFKTtcbiAgICB0aGlzLnNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgTk9PUCwgUEFTU0lWRSk7XG4gIH1cblxuICB1cGRhdGVTaW1wbGVGcmFtZShjYikge1xuICAgIGNvbnN0IHsgZW5kIH0gPSB0aGlzLmdldFN0YXJ0QW5kRW5kKCk7XG4gICAgY29uc3QgaXRlbUVscyA9IHRoaXMuaXRlbXMuY2hpbGRyZW47XG4gICAgbGV0IGVsRW5kID0gMDtcblxuICAgIGlmIChpdGVtRWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgeyBheGlzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgZmlyc3RJdGVtRWwgPSBpdGVtRWxzWzBdO1xuICAgICAgY29uc3QgbGFzdEl0ZW1FbCA9IGl0ZW1FbHNbaXRlbUVscy5sZW5ndGggLSAxXTtcbiAgICAgIGVsRW5kID1cbiAgICAgICAgdGhpcy5nZXRPZmZzZXQobGFzdEl0ZW1FbCkgK1xuICAgICAgICBsYXN0SXRlbUVsW09GRlNFVF9TSVpFX0tFWVNbYXhpc11dIC1cbiAgICAgICAgdGhpcy5nZXRPZmZzZXQoZmlyc3RJdGVtRWwpO1xuICAgIH1cblxuICAgIGlmIChlbEVuZCA+IGVuZCkgcmV0dXJuIGNiKCk7XG5cbiAgICBjb25zdCB7IHBhZ2VTaXplLCBsZW5ndGggfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHRoaXMuc3RhdGUuc2l6ZSArIHBhZ2VTaXplLCBsZW5ndGgpO1xuICAgIHRoaXMubWF5YmVTZXRTdGF0ZSh7IHNpemUgfSwgY2IpO1xuICB9XG5cbiAgdXBkYXRlVmFyaWFibGVGcmFtZShjYikge1xuICAgIGlmICghdGhpcy5wcm9wcy5pdGVtU2l6ZUdldHRlcikgdGhpcy5jYWNoZVNpemVzKCk7XG5cbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMuZ2V0U3RhcnRBbmRFbmQoKTtcbiAgICBjb25zdCB7IGxlbmd0aCwgcGFnZVNpemUgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHNwYWNlID0gMDtcbiAgICBsZXQgZnJvbSA9IDA7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIGNvbnN0IG1heEZyb20gPSBsZW5ndGggLSAxO1xuXG4gICAgd2hpbGUgKGZyb20gPCBtYXhGcm9tKSB7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IHRoaXMuZ2V0U2l6ZU9mSXRlbShmcm9tKTtcbiAgICAgIGlmIChpdGVtU2l6ZSA9PSBudWxsIHx8IHNwYWNlICsgaXRlbVNpemUgPiBzdGFydCkgYnJlYWs7XG4gICAgICBzcGFjZSArPSBpdGVtU2l6ZTtcbiAgICAgICsrZnJvbTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXhTaXplID0gbGVuZ3RoIC0gZnJvbTtcblxuICAgIHdoaWxlIChzaXplIDwgbWF4U2l6ZSAmJiBzcGFjZSA8IGVuZCkge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLmdldFNpemVPZkl0ZW0oZnJvbSArIHNpemUpO1xuICAgICAgaWYgKGl0ZW1TaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUgKyBwYWdlU2l6ZSwgbWF4U2l6ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3BhY2UgKz0gaXRlbVNpemU7XG4gICAgICArK3NpemU7XG4gICAgfVxuICAgIHRoaXMubWF5YmVTZXRTdGF0ZSh7IGZyb20sIHNpemUgfSwgY2IpO1xuICB9XG5cbiAgdXBkYXRlVW5pZm9ybUZyYW1lKGNiKSB7XG4gICAgY29uc3QgeyBpdGVtU2l6ZSwgaXRlbXNQZXJSb3cgfSA9IHRoaXMuZ2V0SXRlbVNpemVBbmRJdGVtc1BlclJvdygpO1xuXG4gICAgaWYgKCFpdGVtU2l6ZSB8fCAhaXRlbXNQZXJSb3cpIHJldHVybiBjYigpO1xuXG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLmdldFN0YXJ0QW5kRW5kKCk7XG5cbiAgICBjb25zdCB7IGZyb20sIHNpemUgfSA9IHRoaXMuY29uc3RyYWluKFxuICAgICAgTWF0aC5mbG9vcihzdGFydCAvIGl0ZW1TaXplKSAqIGl0ZW1zUGVyUm93LFxuICAgICAgKE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gaXRlbVNpemUpICsgMSkgKiBpdGVtc1BlclJvdyxcbiAgICAgIGl0ZW1zUGVyUm93LFxuICAgICAgdGhpcy5wcm9wc1xuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5tYXliZVNldFN0YXRlKHsgaXRlbXNQZXJSb3csIGZyb20sIGl0ZW1TaXplLCBzaXplIH0sIGNiKTtcbiAgfVxuXG4gIGdldFNwYWNlQmVmb3JlKGluZGV4LCBjYWNoZSA9IHt9KSB7XG4gICAgaWYgKGNhY2hlW2luZGV4XSAhPSBudWxsKSByZXR1cm4gY2FjaGVbaW5kZXhdO1xuXG4gICAgLy8gVHJ5IHRoZSBzdGF0aWMgaXRlbVNpemUuXG4gICAgY29uc3QgeyBpdGVtU2l6ZSwgaXRlbXNQZXJSb3cgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGl0ZW1TaXplKSB7XG4gICAgICByZXR1cm4gKGNhY2hlW2luZGV4XSA9IE1hdGguZmxvb3IoaW5kZXggLyBpdGVtc1BlclJvdykgKiBpdGVtU2l6ZSk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBzcGFjZSB0byBpbmRleCB0aGVyZSBpcyBhIGNhY2hlZCB2YWx1ZSBmb3IuXG4gICAgbGV0IGZyb20gPSBpbmRleDtcbiAgICB3aGlsZSAoZnJvbSA+IDAgJiYgY2FjaGVbLS1mcm9tXSA9PSBudWxsKTtcblxuICAgIC8vIEZpbmFsbHksIGFjY3VtdWxhdGUgc2l6ZXMgb2YgaXRlbXMgZnJvbSAtIGluZGV4LlxuICAgIGxldCBzcGFjZSA9IGNhY2hlW2Zyb21dIHx8IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCBpbmRleDsgKytpKSB7XG4gICAgICBjYWNoZVtpXSA9IHNwYWNlO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLmdldFNpemVPZkl0ZW0oaSk7XG4gICAgICBpZiAoaXRlbVNpemUgPT0gbnVsbCkgYnJlYWs7XG4gICAgICBzcGFjZSArPSBpdGVtU2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2luZGV4XSA9IHNwYWNlKTtcbiAgfVxuXG4gIGNhY2hlU2l6ZXMoKSB7XG4gICAgY29uc3QgeyBjYWNoZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGZyb20gfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCF0aGlzLml0ZW1zKSByZXR1cm47XG4gICAgY29uc3QgaXRlbUVscyA9IHRoaXMuaXRlbXMuY2hpbGRyZW47XG4gICAgY29uc3Qgc2l6ZUtleSA9IE9GRlNFVF9TSVpFX0tFWVNbdGhpcy5wcm9wcy5heGlzXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGl0ZW1FbHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBjYWNoZVtmcm9tICsgaV0gPSBpdGVtRWxzW2ldW3NpemVLZXldO1xuICAgIH1cbiAgfVxuXG4gIGdldFNpemVPZkl0ZW0oaW5kZXgpIHtcbiAgICBjb25zdCB7IGNhY2hlLCBpdGVtcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGF4aXMsIGl0ZW1TaXplR2V0dGVyLCBpdGVtU2l6ZUVzdGltYXRvciwgdHlwZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGZyb20sIGl0ZW1TaXplLCBzaXplIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gVHJ5IHRoZSBzdGF0aWMgaXRlbVNpemUuXG4gICAgaWYgKGl0ZW1TaXplKSByZXR1cm4gaXRlbVNpemU7XG5cbiAgICAvLyBUcnkgdGhlIGl0ZW1TaXplR2V0dGVyLlxuICAgIGlmIChpdGVtU2l6ZUdldHRlcikgcmV0dXJuIGl0ZW1TaXplR2V0dGVyKGluZGV4KTtcblxuICAgIC8vIFRyeSB0aGUgY2FjaGUuXG4gICAgaWYgKGluZGV4IGluIGNhY2hlKSByZXR1cm4gY2FjaGVbaW5kZXhdO1xuXG4gICAgLy8gVHJ5IHRoZSBET00uXG4gICAgaWYgKHR5cGUgPT09ICdzaW1wbGUnICYmIGluZGV4ID49IGZyb20gJiYgaW5kZXggPCBmcm9tICsgc2l6ZSAmJiBpdGVtcykge1xuICAgICAgY29uc3QgaXRlbUVsID0gaXRlbXMuY2hpbGRyZW5baW5kZXggLSBmcm9tXTtcbiAgICAgIGlmIChpdGVtRWwpIHJldHVybiBpdGVtRWxbT0ZGU0VUX1NJWkVfS0VZU1theGlzXV07XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRoZSBpdGVtU2l6ZUVzdGltYXRvci5cbiAgICBpZiAoaXRlbVNpemVFc3RpbWF0b3IpIHJldHVybiBpdGVtU2l6ZUVzdGltYXRvcihpbmRleCwgY2FjaGUpO1xuICB9XG5cbiAgY29uc3RyYWluKGZyb20sIHNpemUsIGl0ZW1zUGVyUm93LCB7IGxlbmd0aCwgbWluU2l6ZSwgdHlwZSB9KSB7XG4gICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIG1pblNpemUpO1xuICAgIGxldCBtb2QgPSBzaXplICUgaXRlbXNQZXJSb3c7XG4gICAgaWYgKG1vZCkgc2l6ZSArPSBpdGVtc1BlclJvdyAtIG1vZDtcbiAgICBpZiAoc2l6ZSA+IGxlbmd0aCkgc2l6ZSA9IGxlbmd0aDtcbiAgICBmcm9tID1cbiAgICAgIHR5cGUgPT09ICdzaW1wbGUnIHx8ICFmcm9tXG4gICAgICAgID8gMFxuICAgICAgICA6IE1hdGgubWF4KE1hdGgubWluKGZyb20sIGxlbmd0aCAtIHNpemUpLCAwKTtcblxuICAgIGlmICgobW9kID0gZnJvbSAlIGl0ZW1zUGVyUm93KSkge1xuICAgICAgZnJvbSAtPSBtb2Q7XG4gICAgICBzaXplICs9IG1vZDtcbiAgICB9XG5cbiAgICByZXR1cm4geyBmcm9tLCBzaXplIH07XG4gIH1cblxuICBzY3JvbGxUbyhpbmRleCkge1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB0aGlzLnNldFNjcm9sbCh0aGlzLmdldFNwYWNlQmVmb3JlKGluZGV4KSAtIDEwMCk7XG4gIH1cblxuICBzY3JvbGxBcm91bmQoaW5kZXgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuZ2V0U3BhY2VCZWZvcmUoaW5kZXgpO1xuICAgIGNvbnN0IHRvcCA9IGJvdHRvbSAtIHRoaXMuZ2V0Vmlld3BvcnRTaXplKCkgKyB0aGlzLmdldFNpemVPZkl0ZW0oaW5kZXgpO1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHRvcCwgYm90dG9tKTtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heCh0b3AsIGJvdHRvbSk7XG4gICAgaWYgKGN1cnJlbnQgPD0gbWluKSByZXR1cm4gdGhpcy5zZXRTY3JvbGwobWluIC0gdGhpcy5nZXRWaWV3cG9ydFNpemUoKSk7XG4gICAgaWYgKGN1cnJlbnQgPiBtYXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFNjcm9sbChtYXggLSB0aGlzLmdldFZpZXdwb3J0U2l6ZSgpIC0gMTAwKTtcbiAgICB9XG4gIH1cblxuICBnZXRWaXNpYmxlUmFuZ2UoKSB7XG4gICAgY29uc3QgeyBmcm9tLCBzaXplIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5nZXRTdGFydEFuZEVuZCgwKTtcbiAgICBjb25zdCBjYWNoZSA9IHt9O1xuICAgIGxldCBmaXJzdCwgbGFzdDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IGZyb20gKyBzaXplOyArK2kpIHtcbiAgICAgIGNvbnN0IGl0ZW1TdGFydCA9IHRoaXMuZ2V0U3BhY2VCZWZvcmUoaSwgY2FjaGUpO1xuICAgICAgY29uc3QgaXRlbUVuZCA9IGl0ZW1TdGFydCArIHRoaXMuZ2V0U2l6ZU9mSXRlbShpKTtcbiAgICAgIGlmIChmaXJzdCA9PSBudWxsICYmIGl0ZW1FbmQgPiBzdGFydCkgZmlyc3QgPSBpO1xuICAgICAgaWYgKGZpcnN0ICE9IG51bGwgJiYgaXRlbVN0YXJ0IDwgZW5kKSBsYXN0ID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIFtmaXJzdCwgbGFzdF07XG4gIH1cbiAgLy90aGlzIGNhbiBiZSB1c2VkIGFzIGEgc3RhdGljIG1ldGhvZCB2aWEgdGhlIHJlYWN0IGxpc3QgcmVmXG4gIGdldEZyYWN0aW9uYWxWaXNpYmxlUmFuZ2UoKSB7XG4gICAgY29uc3QgeyBmcm9tLCBzaXplIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5nZXRTdGFydEFuZEVuZCgwKTtcbiAgICBjb25zdCBjYWNoZSA9IHt9O1xuICAgIGxldCBmaXJzdCwgbGFzdDtcblxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgZnJvbSArIHNpemU7ICsraSkge1xuICAgICAgY29uc3QgaXRlbVN0YXJ0ID0gdGhpcy5nZXRTcGFjZUJlZm9yZShpLCBjYWNoZSk7XG4gICAgICBjb25zdCBpdGVtRW5kID0gaXRlbVN0YXJ0ICsgdGhpcy5nZXRTaXplT2ZJdGVtKGkpO1xuICAgICAgaWYgKGZpcnN0ID09IG51bGwgJiYgaXRlbUVuZCA+IHN0YXJ0KSB7XG4gICAgICAgIGZpcnN0ID0gaSArIDEgLSAoaXRlbUVuZCAtIHN0YXJ0KSAvIChpdGVtRW5kIC0gaXRlbVN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdCAhPSBudWxsICYmIGl0ZW1TdGFydCA8IGVuZCkge1xuICAgICAgICBsYXN0ID0gaSAtIChpdGVtRW5kIC0gZW5kKSAvIChpdGVtRW5kIC0gaXRlbVN0YXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtmaXJzdCwgbGFzdF07XG4gIH1cblxuICByZW5kZXJJdGVtcygpIHtcbiAgICBjb25zdCB7IGl0ZW1SZW5kZXJlciwgaXRlbXNSZW5kZXJlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGZyb20sIHNpemUgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7ICsraSkgaXRlbXMucHVzaChpdGVtUmVuZGVyZXIoZnJvbSArIGksIGkpKTtcbiAgICByZXR1cm4gaXRlbXNSZW5kZXJlcihpdGVtcywgYyA9PiAodGhpcy5pdGVtcyA9IGMpKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGF4aXMsIGxlbmd0aCwgdHlwZSAvKiB1c2VUcmFuc2xhdGUzZCAqLyB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGZyb20sIGl0ZW1zUGVyUm93IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5yZW5kZXJJdGVtcygpO1xuICAgIGlmICh0eXBlID09PSAnc2ltcGxlJykgcmV0dXJuIGl0ZW1zO1xuXG4gICAgY29uc3Qgc3R5bGUgPSB7IHBvc2l0aW9uOiAncmVsYXRpdmUnIH07XG4gICAgY29uc3QgY2FjaGUgPSB7fTtcbiAgICBjb25zdCBib3R0b20gPSBNYXRoLmNlaWwobGVuZ3RoIC8gaXRlbXNQZXJSb3cpICogaXRlbXNQZXJSb3c7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U3BhY2VCZWZvcmUoYm90dG9tLCBjYWNoZSk7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgIHN0eWxlW1NJWkVfS0VZU1theGlzXV0gPSBzaXplO1xuICAgICAgaWYgKGF4aXMgPT09ICd4Jykgc3R5bGUub3ZlcmZsb3dYID0gJ2hpZGRlbic7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuZ2V0U3BhY2VCZWZvcmUoZnJvbSwgY2FjaGUpO1xuICAgIGNvbnN0IHggPSBheGlzID09PSAneCcgPyBvZmZzZXQgOiAwO1xuICAgIGNvbnN0IHkgPSBheGlzID09PSAneScgPyBvZmZzZXQgOiAwO1xuICAgIGNvbnN0IGxpc3RTdHlsZSA9IHtcbiAgICAgIC8vdG5yIHRyeWluZyBvdXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlcmlldHkvcmVhY3QtbGlzdC9wdWxsLzE1NFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB0b3A6IHksXG4gICAgICBsZWZ0OiB4XG4gICAgfTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgIHJlZj17YyA9PiB7XG4gICAgICAgICAgaWYgKGMpIHRoaXMuZWwgPSBjO1xuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8ZGl2IHN0eWxlPXtsaXN0U3R5bGV9PntpdGVtc308L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ==