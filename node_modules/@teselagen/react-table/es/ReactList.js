var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable no-empty */
/* eslint-disable no-cond-assign */
/* eslint-disable no-cond-assign */
/* eslint-disable default-case */
/* eslint-disable default-case */
/* eslint-disable no-cond-assign */
// import module from 'module';
import PropTypes from 'prop-types';
import React from 'react';

var CLIENT_SIZE_KEYS = { x: 'clientWidth', y: 'clientHeight' };
var CLIENT_START_KEYS = { x: 'clientTop', y: 'clientLeft' };
var INNER_SIZE_KEYS = { x: 'innerWidth', y: 'innerHeight' };
var OFFSET_SIZE_KEYS = { x: 'offsetWidth', y: 'offsetHeight' };
var OFFSET_START_KEYS = { x: 'offsetLeft', y: 'offsetTop' };
var OVERFLOW_KEYS = { x: 'overflowX', y: 'overflowY' };
var SCROLL_SIZE_KEYS = { x: 'scrollWidth', y: 'scrollHeight' };
var SCROLL_START_KEYS = { x: 'scrollLeft', y: 'scrollTop' };
var SIZE_KEYS = { x: 'minWidth', y: 'minHeight' };

var NOOP = function NOOP() {};

// If a browser doesn't support the `options` argument to
// add/removeEventListener, we need to check, otherwise we will
// accidentally set `capture` with a truthy value.
var PASSIVE = function () {
  if (typeof window === 'undefined') return false;
  var hasSupport = false;
  try {
    document.createElement('div').addEventListener('test', NOOP, {
      get passive() {
        hasSupport = true;
        return false;
      }
    });
  } catch (e) {
    // noop
  }
  return hasSupport;
}() ? { passive: true } : false;

var UNSTABLE_MESSAGE = 'ReactList failed to reach a stable state.';
var MAX_SYNC_UPDATES = 100;

var isEqualSubset = function isEqualSubset(a, b) {
  for (var key in b) {
    if (a[key] !== b[key]) return false;
  }return true;
};

var ReactList = function (_React$Component) {
  _inherits(ReactList, _React$Component);

  function ReactList(props) {
    _classCallCheck(this, ReactList);

    var _this = _possibleConstructorReturn(this, (ReactList.__proto__ || Object.getPrototypeOf(ReactList)).call(this, props));

    var initialIndex = props.initialIndex;

    var itemsPerRow = 1;

    var _this$constrain = _this.constrain(initialIndex, 0, itemsPerRow, props),
        from = _this$constrain.from,
        size = _this$constrain.size;

    _this.state = { from: from, size: size, itemsPerRow: itemsPerRow };
    _this.cache = {};
    _this.prevPrevState = {};
    _this.unstable = false;
    _this.updateCounter = 0;
    return _this;
  }

  //tnr: commenting this out.. not sure if it is actually needed
  // UNSAFE_componentWillReceiveProps(nextProps) {
  //   let { from, size, itemsPerRow } = this.state;
  //   if (nextProps.clearCache) this.cache = {};
  //   this.maybeSetState(
  //     this.constrain(from, size, itemsPerRow, nextProps),
  //     NOOP
  //   );
  // }

  _createClass(ReactList, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateFrame = this.updateFrame.bind(this);
      window.addEventListener('resize', this.updateFrame);
      this.updateFrame(this.scrollTo.bind(this, this.props.initialIndex));
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      var _this2 = this;

      // If the list has reached an unstable state, prevent an infinite loop.
      if (this.unstable) return;

      if (++this.updateCounter > MAX_SYNC_UPDATES) {
        this.unstable = true;
        return console.error(UNSTABLE_MESSAGE);
      }

      if (!this.updateCounterTimeoutId) {
        this.updateCounterTimeoutId = setTimeout(function () {
          _this2.updateCounter = 0;
          delete _this2.updateCounterTimeoutId;
        }, 0);
      }
      // this.dontUpdate = true;
      this.updateFrame();

      //TNR: extra code to 'fix' the scroll height when scrolling upwards
      //tnr commenting this out because we are now doing a better job of calculating row heights
      // if (this.rowToFixScroll) {
      //   const { row, cache: previousSize } = this.rowToFixScroll;
      //   const actualSize = this.cache[row];
      //   if (actualSize && actualSize !== previousSize) {
      //     this.getScrollParent().scrollBy({
      //       top: -(
      //         (previousSize || this.props.itemSizeEstimator(row, {})) - actualSize
      //       )
      //     });
      //     this.rowToFixScroll = null;
      //   }
      // }
    }
    // shouldComponentUpdate() {
    //   if (this.dontUpdate) {
    //     this.dontUpdate = false;
    //     return false;
    //   }
    //   return true;
    // }

  }, {
    key: 'maybeSetState',
    value: function maybeSetState(b, cb) {
      if (isEqualSubset(this.state, b)) return cb();

      //TNR: extra code to 'fix' the scroll height when scrolling upwards
      if (this.state.from === b.from + 1) {
        this.rowToFixScroll = { row: b.from, cache: this.cache[b.from] };
      }
      this.setState(b, cb);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.updateFrame);
      this.scrollParent.removeEventListener('scroll', this.updateFrame, PASSIVE);
      this.scrollParent.removeEventListener('mousewheel', NOOP, PASSIVE);
    }
  }, {
    key: 'getOffset',
    value: function getOffset(el) {
      var axis = this.props.axis;

      var offset = el[CLIENT_START_KEYS[axis]] || 0;
      var offsetKey = OFFSET_START_KEYS[axis];
      do {
        offset += el[offsetKey] || 0;
      } while (el = el.offsetParent);
      return offset;
    }
  }, {
    key: 'getEl',
    value: function getEl() {
      return this.el || this.items;
    }
  }, {
    key: 'getScrollParent',
    value: function getScrollParent() {
      var _props = this.props,
          axis = _props.axis,
          scrollParentGetter = _props.scrollParentGetter;

      if (scrollParentGetter) return scrollParentGetter();
      var el = this.getEl();
      if (!el) return window;
      var overflowKey = OVERFLOW_KEYS[axis];
      while (el = el.parentElement) {
        switch (window.getComputedStyle(el)[overflowKey]) {
          case 'auto':
          case 'scroll':
          case 'overlay':
            return el;
        }
      }
      return window;
    }
  }, {
    key: 'getScrollPosition',
    value: function getScrollPosition() {
      var scrollParent = this.scrollParent;
      var axis = this.props.axis;

      var scrollKey = SCROLL_START_KEYS[axis];
      var actual = scrollParent === window ? // Firefox always returns document.body[scrollKey] as 0 and Chrome/Safari
      // always return document.documentElement[scrollKey] as 0, so take
      // whichever has a value.
      document.body[scrollKey] || document.documentElement[scrollKey] : scrollParent[scrollKey];
      var max = this.getScrollSize() - this.getViewportSize();
      var scroll = Math.max(0, Math.min(actual, max));
      var el = this.getEl();
      return this.getOffset(scrollParent) + scroll - this.getOffset(el);
    }
  }, {
    key: 'setScroll',
    value: function setScroll(offset) {
      var scrollParent = this.scrollParent;
      var axis = this.props.axis;

      offset += this.getOffset(this.getEl());
      if (scrollParent === window) return window.scrollTo(0, offset);

      offset -= this.getOffset(this.scrollParent);
      scrollParent[SCROLL_START_KEYS[axis]] = offset;
    }
  }, {
    key: 'getViewportSize',
    value: function getViewportSize() {
      var scrollParent = this.scrollParent;
      var axis = this.props.axis;

      return scrollParent === window ? window[INNER_SIZE_KEYS[axis]] : scrollParent[CLIENT_SIZE_KEYS[axis]];
    }
  }, {
    key: 'getScrollSize',
    value: function getScrollSize() {
      var scrollParent = this.scrollParent;
      var _document = document,
          body = _document.body,
          documentElement = _document.documentElement;

      var key = SCROLL_SIZE_KEYS[this.props.axis];
      return scrollParent === window ? Math.max(body[key], documentElement[key]) : scrollParent[key];
    }
  }, {
    key: 'hasDeterminateSize',
    value: function hasDeterminateSize() {
      var _props2 = this.props,
          itemSizeGetter = _props2.itemSizeGetter,
          type = _props2.type;

      return type === 'uniform' || itemSizeGetter;
    }
  }, {
    key: 'getStartAndEnd',
    value: function getStartAndEnd() {
      var threshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.threshold;

      var scroll = this.getScrollPosition();
      var start = Math.max(0, scroll - threshold);
      var end = scroll + this.getViewportSize() + threshold;
      if (this.hasDeterminateSize()) {
        end = Math.min(end, this.getSpaceBefore(this.props.length));
      }
      return { start: start, end: end };
    }
  }, {
    key: 'getItemSizeAndItemsPerRow',
    value: function getItemSizeAndItemsPerRow() {
      var _props3 = this.props,
          axis = _props3.axis,
          useStaticSize = _props3.useStaticSize;
      var _state = this.state,
          itemSize = _state.itemSize,
          itemsPerRow = _state.itemsPerRow;

      if (useStaticSize && itemSize && itemsPerRow) {
        return { itemSize: itemSize, itemsPerRow: itemsPerRow };
      }

      var itemEls = this.items.children;
      if (!itemEls.length) return {};

      var firstEl = itemEls[0];

      // Firefox has a problem where it will return a *slightly* (less than
      // thousandths of a pixel) different size for the same element between
      // renders. This can cause an infinite render loop, so only change the
      // itemSize when it is significantly different.
      var firstElSize = firstEl[OFFSET_SIZE_KEYS[axis]];
      var delta = Math.abs(firstElSize - itemSize);
      if (isNaN(delta) || delta >= 1) itemSize = firstElSize;

      if (!itemSize) return {};

      var startKey = OFFSET_START_KEYS[axis];
      var firstStart = firstEl[startKey];
      itemsPerRow = 1;
      for (var item = itemEls[itemsPerRow]; item && item[startKey] === firstStart; item = itemEls[itemsPerRow]) {
        ++itemsPerRow;
      }

      return { itemSize: itemSize, itemsPerRow: itemsPerRow };
    }
  }, {
    key: 'updateFrame',
    value: function updateFrame(cb) {
      this.updateScrollParent();
      if (typeof cb !== 'function') cb = NOOP;
      switch (this.props.type) {
        case 'simple':
          return this.updateSimpleFrame(cb);
        case 'variable':
          return this.updateVariableFrame(cb);
        case 'uniform':
          return this.updateUniformFrame(cb);
      }
    }
  }, {
    key: 'updateScrollParent',
    value: function updateScrollParent() {
      var prev = this.scrollParent;
      if (prev) {
        return; //https://github.com/coderiety/react-list/pull/196
      }
      this.scrollParent = this.getScrollParent();
      if (prev === this.scrollParent) return;
      if (prev) {
        prev.removeEventListener('scroll', this.updateFrame);
        prev.removeEventListener('mousewheel', NOOP);
      }
      this.scrollParent.addEventListener('scroll', this.updateFrame, PASSIVE);
      this.scrollParent.addEventListener('mousewheel', NOOP, PASSIVE);
    }
  }, {
    key: 'updateSimpleFrame',
    value: function updateSimpleFrame(cb) {
      var _getStartAndEnd = this.getStartAndEnd(),
          end = _getStartAndEnd.end;

      var itemEls = this.items.children;
      var elEnd = 0;

      if (itemEls.length) {
        var axis = this.props.axis;

        var firstItemEl = itemEls[0];
        var lastItemEl = itemEls[itemEls.length - 1];
        elEnd = this.getOffset(lastItemEl) + lastItemEl[OFFSET_SIZE_KEYS[axis]] - this.getOffset(firstItemEl);
      }

      if (elEnd > end) return cb();

      var _props4 = this.props,
          pageSize = _props4.pageSize,
          length = _props4.length;

      var size = Math.min(this.state.size + pageSize, length);
      this.maybeSetState({ size: size }, cb);
    }
  }, {
    key: 'updateVariableFrame',
    value: function updateVariableFrame(cb) {
      if (!this.props.itemSizeGetter) this.cacheSizes();

      var _getStartAndEnd2 = this.getStartAndEnd(),
          start = _getStartAndEnd2.start,
          end = _getStartAndEnd2.end;

      var _props5 = this.props,
          length = _props5.length,
          pageSize = _props5.pageSize;

      var space = 0;
      var from = 0;
      var size = 0;
      var maxFrom = length - 1;

      while (from < maxFrom) {
        var itemSize = this.getSizeOfItem(from);
        if (itemSize == null || space + itemSize > start) break;
        space += itemSize;
        ++from;
      }

      var maxSize = length - from;

      while (size < maxSize && space < end) {
        var _itemSize = this.getSizeOfItem(from + size);
        if (_itemSize == null) {
          size = Math.min(size + pageSize, maxSize);
          break;
        }
        space += _itemSize;
        ++size;
      }
      this.maybeSetState({ from: from, size: size }, cb);
    }
  }, {
    key: 'updateUniformFrame',
    value: function updateUniformFrame(cb) {
      var _getItemSizeAndItemsP = this.getItemSizeAndItemsPerRow(),
          itemSize = _getItemSizeAndItemsP.itemSize,
          itemsPerRow = _getItemSizeAndItemsP.itemsPerRow;

      if (!itemSize || !itemsPerRow) return cb();

      var _getStartAndEnd3 = this.getStartAndEnd(),
          start = _getStartAndEnd3.start,
          end = _getStartAndEnd3.end;

      var _constrain = this.constrain(Math.floor(start / itemSize) * itemsPerRow, (Math.ceil((end - start) / itemSize) + 1) * itemsPerRow, itemsPerRow, this.props),
          from = _constrain.from,
          size = _constrain.size;

      return this.maybeSetState({ itemsPerRow: itemsPerRow, from: from, itemSize: itemSize, size: size }, cb);
    }
  }, {
    key: 'getSpaceBefore',
    value: function getSpaceBefore(index) {
      var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (cache[index] != null) return cache[index];

      // Try the static itemSize.
      var _state2 = this.state,
          itemSize = _state2.itemSize,
          itemsPerRow = _state2.itemsPerRow;

      if (itemSize) {
        return cache[index] = Math.floor(index / itemsPerRow) * itemSize;
      }

      // Find the closest space to index there is a cached value for.
      var from = index;
      while (from > 0 && cache[--from] == null) {}

      // Finally, accumulate sizes of items from - index.
      var space = cache[from] || 0;
      for (var i = from; i < index; ++i) {
        cache[i] = space;
        var _itemSize2 = this.getSizeOfItem(i);
        if (_itemSize2 == null) break;
        space += _itemSize2;
      }

      return cache[index] = space;
    }
  }, {
    key: 'cacheSizes',
    value: function cacheSizes() {
      var cache = this.cache;
      var from = this.state.from;

      if (!this.items) return;
      var itemEls = this.items.children;
      var sizeKey = OFFSET_SIZE_KEYS[this.props.axis];
      for (var i = 0, l = itemEls.length; i < l; ++i) {
        cache[from + i] = itemEls[i][sizeKey];
      }
    }
  }, {
    key: 'getSizeOfItem',
    value: function getSizeOfItem(index) {
      var cache = this.cache,
          items = this.items;
      var _props6 = this.props,
          axis = _props6.axis,
          itemSizeGetter = _props6.itemSizeGetter,
          itemSizeEstimator = _props6.itemSizeEstimator,
          type = _props6.type;
      var _state3 = this.state,
          from = _state3.from,
          itemSize = _state3.itemSize,
          size = _state3.size;

      // Try the static itemSize.

      if (itemSize) return itemSize;

      // Try the itemSizeGetter.
      if (itemSizeGetter) return itemSizeGetter(index);

      // Try the cache.
      if (index in cache) return cache[index];

      // Try the DOM.
      if (type === 'simple' && index >= from && index < from + size && items) {
        var itemEl = items.children[index - from];
        if (itemEl) return itemEl[OFFSET_SIZE_KEYS[axis]];
      }

      // Try the itemSizeEstimator.
      if (itemSizeEstimator) return itemSizeEstimator(index, cache);
    }
  }, {
    key: 'constrain',
    value: function constrain(from, size, itemsPerRow, _ref) {
      var length = _ref.length,
          minSize = _ref.minSize,
          type = _ref.type;

      size = Math.max(size, minSize);
      var mod = size % itemsPerRow;
      if (mod) size += itemsPerRow - mod;
      if (size > length) size = length;
      from = type === 'simple' || !from ? 0 : Math.max(Math.min(from, length - size), 0);

      if (mod = from % itemsPerRow) {
        from -= mod;
        size += mod;
      }

      return { from: from, size: size };
    }
  }, {
    key: 'scrollTo',
    value: function scrollTo(index) {
      if (index != null) this.setScroll(this.getSpaceBefore(index) - 100);
    }
  }, {
    key: 'scrollAround',
    value: function scrollAround(index) {
      var current = this.getScrollPosition();
      var bottom = this.getSpaceBefore(index);
      var top = bottom - this.getViewportSize() + this.getSizeOfItem(index);
      var min = Math.min(top, bottom);
      var max = Math.max(top, bottom);
      if (current <= min) return this.setScroll(min - this.getViewportSize());
      if (current > max) {
        return this.setScroll(max - this.getViewportSize() - 100);
      }
    }
  }, {
    key: 'getVisibleRange',
    value: function getVisibleRange() {
      var _state4 = this.state,
          from = _state4.from,
          size = _state4.size;

      var _getStartAndEnd4 = this.getStartAndEnd(0),
          start = _getStartAndEnd4.start,
          end = _getStartAndEnd4.end;

      var cache = {};
      var first = void 0,
          last = void 0;
      for (var i = from; i < from + size; ++i) {
        var itemStart = this.getSpaceBefore(i, cache);
        var itemEnd = itemStart + this.getSizeOfItem(i);
        if (first == null && itemEnd > start) first = i;
        if (first != null && itemStart < end) last = i;
      }
      return [first, last];
    }
    //this can be used as a static method via the react list ref

  }, {
    key: 'getFractionalVisibleRange',
    value: function getFractionalVisibleRange() {
      var _state5 = this.state,
          from = _state5.from,
          size = _state5.size;

      var _getStartAndEnd5 = this.getStartAndEnd(0),
          start = _getStartAndEnd5.start,
          end = _getStartAndEnd5.end;

      var cache = {};
      var first = void 0,
          last = void 0;

      for (var i = from; i < from + size; ++i) {
        var itemStart = this.getSpaceBefore(i, cache);
        var itemEnd = itemStart + this.getSizeOfItem(i);
        if (first == null && itemEnd > start) {
          first = i + 1 - (itemEnd - start) / (itemEnd - itemStart);
        }
        if (first != null && itemStart < end) {
          last = i - (itemEnd - end) / (itemEnd - itemStart);
        }
      }
      return [first, last];
    }
  }, {
    key: 'renderItems',
    value: function renderItems() {
      var _this3 = this;

      var _props7 = this.props,
          itemRenderer = _props7.itemRenderer,
          itemsRenderer = _props7.itemsRenderer;
      var _state6 = this.state,
          from = _state6.from,
          size = _state6.size;

      var items = [];
      for (var i = 0; i < size; ++i) {
        items.push(itemRenderer(from + i, i));
      }return itemsRenderer(items, function (c) {
        return _this3.items = c;
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props8 = this.props,
          axis = _props8.axis,
          length = _props8.length,
          type = _props8.type;
      var _state7 = this.state,
          from = _state7.from,
          itemsPerRow = _state7.itemsPerRow;

      var items = this.renderItems();
      if (type === 'simple') return items;

      var style = { position: 'relative' };
      var cache = {};
      var bottom = Math.ceil(length / itemsPerRow) * itemsPerRow;
      var size = this.getSpaceBefore(bottom, cache);
      if (size) {
        style[SIZE_KEYS[axis]] = size;
        if (axis === 'x') style.overflowX = 'hidden';
      }
      var offset = this.getSpaceBefore(from, cache);
      var x = axis === 'x' ? offset : 0;
      var y = axis === 'y' ? offset : 0;
      var listStyle = {
        //tnr trying out: https://github.com/coderiety/react-list/pull/154
        position: 'relative',
        top: y,
        left: x
      };
      return React.createElement(
        'div',
        {
          style: style,
          ref: function ref(c) {
            if (c) _this4.el = c;
          }
        },
        React.createElement(
          'div',
          { style: listStyle },
          items
        )
      );
    }
  }]);

  return ReactList;
}(React.Component);

ReactList.displayName = 'ReactList';
ReactList.propTypes = {
  axis: PropTypes.oneOf(['x', 'y']),
  initialIndex: PropTypes.number,
  itemRenderer: PropTypes.func,
  itemSizeEstimator: PropTypes.func,
  itemSizeGetter: PropTypes.func,
  itemsRenderer: PropTypes.func,
  length: PropTypes.number,
  minSize: PropTypes.number,
  pageSize: PropTypes.number,
  scrollParentGetter: PropTypes.func,
  threshold: PropTypes.number,
  type: PropTypes.oneOf(['simple', 'variable', 'uniform']),
  useStaticSize: PropTypes.bool,
  useTranslate3d: PropTypes.bool
};
ReactList.defaultProps = {
  axis: 'y',
  itemRenderer: function itemRenderer(index, key) {
    return React.createElement(
      'div',
      { key: key },
      index
    );
  },
  itemsRenderer: function itemsRenderer(items, ref) {
    return React.createElement(
      'div',
      { ref: ref },
      items
    );
  },
  length: 0,
  minSize: 1,
  pageSize: 10,
  threshold: 100,
  type: 'simple',
  useStaticSize: false,
  useTranslate3d: false
};
export default ReactList;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdExpc3QuanMiXSwibmFtZXMiOlsiUHJvcFR5cGVzIiwiUmVhY3QiLCJDTElFTlRfU0laRV9LRVlTIiwieCIsInkiLCJDTElFTlRfU1RBUlRfS0VZUyIsIklOTkVSX1NJWkVfS0VZUyIsIk9GRlNFVF9TSVpFX0tFWVMiLCJPRkZTRVRfU1RBUlRfS0VZUyIsIk9WRVJGTE9XX0tFWVMiLCJTQ1JPTExfU0laRV9LRVlTIiwiU0NST0xMX1NUQVJUX0tFWVMiLCJTSVpFX0tFWVMiLCJOT09QIiwiUEFTU0lWRSIsIndpbmRvdyIsImhhc1N1cHBvcnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImUiLCJVTlNUQUJMRV9NRVNTQUdFIiwiTUFYX1NZTkNfVVBEQVRFUyIsImlzRXF1YWxTdWJzZXQiLCJhIiwiYiIsImtleSIsIlJlYWN0TGlzdCIsInByb3BzIiwiaW5pdGlhbEluZGV4IiwiaXRlbXNQZXJSb3ciLCJjb25zdHJhaW4iLCJmcm9tIiwic2l6ZSIsInN0YXRlIiwiY2FjaGUiLCJwcmV2UHJldlN0YXRlIiwidW5zdGFibGUiLCJ1cGRhdGVDb3VudGVyIiwidXBkYXRlRnJhbWUiLCJiaW5kIiwic2Nyb2xsVG8iLCJjb25zb2xlIiwiZXJyb3IiLCJ1cGRhdGVDb3VudGVyVGltZW91dElkIiwic2V0VGltZW91dCIsImNiIiwicm93VG9GaXhTY3JvbGwiLCJyb3ciLCJzZXRTdGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzY3JvbGxQYXJlbnQiLCJlbCIsImF4aXMiLCJvZmZzZXQiLCJvZmZzZXRLZXkiLCJvZmZzZXRQYXJlbnQiLCJpdGVtcyIsInNjcm9sbFBhcmVudEdldHRlciIsImdldEVsIiwib3ZlcmZsb3dLZXkiLCJwYXJlbnRFbGVtZW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInNjcm9sbEtleSIsImFjdHVhbCIsImJvZHkiLCJkb2N1bWVudEVsZW1lbnQiLCJtYXgiLCJnZXRTY3JvbGxTaXplIiwiZ2V0Vmlld3BvcnRTaXplIiwic2Nyb2xsIiwiTWF0aCIsIm1pbiIsImdldE9mZnNldCIsIml0ZW1TaXplR2V0dGVyIiwidHlwZSIsInRocmVzaG9sZCIsImdldFNjcm9sbFBvc2l0aW9uIiwic3RhcnQiLCJlbmQiLCJoYXNEZXRlcm1pbmF0ZVNpemUiLCJnZXRTcGFjZUJlZm9yZSIsImxlbmd0aCIsInVzZVN0YXRpY1NpemUiLCJpdGVtU2l6ZSIsIml0ZW1FbHMiLCJjaGlsZHJlbiIsImZpcnN0RWwiLCJmaXJzdEVsU2l6ZSIsImRlbHRhIiwiYWJzIiwiaXNOYU4iLCJzdGFydEtleSIsImZpcnN0U3RhcnQiLCJpdGVtIiwidXBkYXRlU2Nyb2xsUGFyZW50IiwidXBkYXRlU2ltcGxlRnJhbWUiLCJ1cGRhdGVWYXJpYWJsZUZyYW1lIiwidXBkYXRlVW5pZm9ybUZyYW1lIiwicHJldiIsImdldFNjcm9sbFBhcmVudCIsImdldFN0YXJ0QW5kRW5kIiwiZWxFbmQiLCJmaXJzdEl0ZW1FbCIsImxhc3RJdGVtRWwiLCJwYWdlU2l6ZSIsIm1heWJlU2V0U3RhdGUiLCJjYWNoZVNpemVzIiwic3BhY2UiLCJtYXhGcm9tIiwiZ2V0U2l6ZU9mSXRlbSIsIm1heFNpemUiLCJnZXRJdGVtU2l6ZUFuZEl0ZW1zUGVyUm93IiwiZmxvb3IiLCJjZWlsIiwiaW5kZXgiLCJpIiwic2l6ZUtleSIsImwiLCJpdGVtU2l6ZUVzdGltYXRvciIsIml0ZW1FbCIsIm1pblNpemUiLCJtb2QiLCJzZXRTY3JvbGwiLCJjdXJyZW50IiwiYm90dG9tIiwidG9wIiwiZmlyc3QiLCJsYXN0IiwiaXRlbVN0YXJ0IiwiaXRlbUVuZCIsIml0ZW1SZW5kZXJlciIsIml0ZW1zUmVuZGVyZXIiLCJwdXNoIiwiYyIsInJlbmRlckl0ZW1zIiwic3R5bGUiLCJwb3NpdGlvbiIsIm92ZXJmbG93WCIsImxpc3RTdHlsZSIsImxlZnQiLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsInByb3BUeXBlcyIsIm9uZU9mIiwibnVtYmVy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InNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIGRlZmF1bHQtY2FzZSAqL1xuLyogZXNsaW50LWRpc2FibGUgZGVmYXVsdC1jYXNlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuLy8gaW1wb3J0IG1vZHVsZSBmcm9tICdtb2R1bGUnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IENMSUVOVF9TSVpFX0tFWVMgPSB7IHg6ICdjbGllbnRXaWR0aCcsIHk6ICdjbGllbnRIZWlnaHQnIH07XG5jb25zdCBDTElFTlRfU1RBUlRfS0VZUyA9IHsgeDogJ2NsaWVudFRvcCcsIHk6ICdjbGllbnRMZWZ0JyB9O1xuY29uc3QgSU5ORVJfU0laRV9LRVlTID0geyB4OiAnaW5uZXJXaWR0aCcsIHk6ICdpbm5lckhlaWdodCcgfTtcbmNvbnN0IE9GRlNFVF9TSVpFX0tFWVMgPSB7IHg6ICdvZmZzZXRXaWR0aCcsIHk6ICdvZmZzZXRIZWlnaHQnIH07XG5jb25zdCBPRkZTRVRfU1RBUlRfS0VZUyA9IHsgeDogJ29mZnNldExlZnQnLCB5OiAnb2Zmc2V0VG9wJyB9O1xuY29uc3QgT1ZFUkZMT1dfS0VZUyA9IHsgeDogJ292ZXJmbG93WCcsIHk6ICdvdmVyZmxvd1knIH07XG5jb25zdCBTQ1JPTExfU0laRV9LRVlTID0geyB4OiAnc2Nyb2xsV2lkdGgnLCB5OiAnc2Nyb2xsSGVpZ2h0JyB9O1xuY29uc3QgU0NST0xMX1NUQVJUX0tFWVMgPSB7IHg6ICdzY3JvbGxMZWZ0JywgeTogJ3Njcm9sbFRvcCcgfTtcbmNvbnN0IFNJWkVfS0VZUyA9IHsgeDogJ21pbldpZHRoJywgeTogJ21pbkhlaWdodCcgfTtcblxuY29uc3QgTk9PUCA9ICgpID0+IHt9O1xuXG4vLyBJZiBhIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgdG9cbi8vIGFkZC9yZW1vdmVFdmVudExpc3RlbmVyLCB3ZSBuZWVkIHRvIGNoZWNrLCBvdGhlcndpc2Ugd2Ugd2lsbFxuLy8gYWNjaWRlbnRhbGx5IHNldCBgY2FwdHVyZWAgd2l0aCBhIHRydXRoeSB2YWx1ZS5cbmNvbnN0IFBBU1NJVkUgPSAoKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgbGV0IGhhc1N1cHBvcnQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgTk9PUCwge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGhhc1N1cHBvcnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBub29wXG4gIH1cbiAgcmV0dXJuIGhhc1N1cHBvcnQ7XG59KSgpXG4gID8geyBwYXNzaXZlOiB0cnVlIH1cbiAgOiBmYWxzZTtcblxuY29uc3QgVU5TVEFCTEVfTUVTU0FHRSA9ICdSZWFjdExpc3QgZmFpbGVkIHRvIHJlYWNoIGEgc3RhYmxlIHN0YXRlLic7XG5jb25zdCBNQVhfU1lOQ19VUERBVEVTID0gMTAwO1xuXG5jb25zdCBpc0VxdWFsU3Vic2V0ID0gKGEsIGIpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gYikgaWYgKGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFjdExpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgZGlzcGxheU5hbWUgPSAnUmVhY3RMaXN0JztcblxuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGF4aXM6IFByb3BUeXBlcy5vbmVPZihbJ3gnLCAneSddKSxcbiAgICBpbml0aWFsSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgaXRlbVJlbmRlcmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBpdGVtU2l6ZUVzdGltYXRvcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaXRlbVNpemVHZXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGl0ZW1zUmVuZGVyZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBtaW5TaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHBhZ2VTaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHNjcm9sbFBhcmVudEdldHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgdGhyZXNob2xkOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ3NpbXBsZScsICd2YXJpYWJsZScsICd1bmlmb3JtJ10pLFxuICAgIHVzZVN0YXRpY1NpemU6IFByb3BUeXBlcy5ib29sLFxuICAgIHVzZVRyYW5zbGF0ZTNkOiBQcm9wVHlwZXMuYm9vbFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgYXhpczogJ3knLFxuICAgIGl0ZW1SZW5kZXJlcjogKGluZGV4LCBrZXkpID0+IDxkaXYga2V5PXtrZXl9PntpbmRleH08L2Rpdj4sXG4gICAgaXRlbXNSZW5kZXJlcjogKGl0ZW1zLCByZWYpID0+IDxkaXYgcmVmPXtyZWZ9PntpdGVtc308L2Rpdj4sXG4gICAgbGVuZ3RoOiAwLFxuICAgIG1pblNpemU6IDEsXG4gICAgcGFnZVNpemU6IDEwLFxuICAgIHRocmVzaG9sZDogMTAwLFxuICAgIHR5cGU6ICdzaW1wbGUnLFxuICAgIHVzZVN0YXRpY1NpemU6IGZhbHNlLFxuICAgIHVzZVRyYW5zbGF0ZTNkOiBmYWxzZVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIGNvbnN0IHsgaW5pdGlhbEluZGV4IH0gPSBwcm9wcztcbiAgICBjb25zdCBpdGVtc1BlclJvdyA9IDE7XG4gICAgY29uc3QgeyBmcm9tLCBzaXplIH0gPSB0aGlzLmNvbnN0cmFpbihpbml0aWFsSW5kZXgsIDAsIGl0ZW1zUGVyUm93LCBwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgZnJvbSwgc2l6ZSwgaXRlbXNQZXJSb3cgfTtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gICAgdGhpcy5wcmV2UHJldlN0YXRlID0ge307XG4gICAgdGhpcy51bnN0YWJsZSA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlQ291bnRlciA9IDA7XG4gIH1cblxuICAvL3RucjogY29tbWVudGluZyB0aGlzIG91dC4uIG5vdCBzdXJlIGlmIGl0IGlzIGFjdHVhbGx5IG5lZWRlZFxuICAvLyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgLy8gICBsZXQgeyBmcm9tLCBzaXplLCBpdGVtc1BlclJvdyB9ID0gdGhpcy5zdGF0ZTtcbiAgLy8gICBpZiAobmV4dFByb3BzLmNsZWFyQ2FjaGUpIHRoaXMuY2FjaGUgPSB7fTtcbiAgLy8gICB0aGlzLm1heWJlU2V0U3RhdGUoXG4gIC8vICAgICB0aGlzLmNvbnN0cmFpbihmcm9tLCBzaXplLCBpdGVtc1BlclJvdywgbmV4dFByb3BzKSxcbiAgLy8gICAgIE5PT1BcbiAgLy8gICApO1xuICAvLyB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVGcmFtZSA9IHRoaXMudXBkYXRlRnJhbWUuYmluZCh0aGlzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy51cGRhdGVGcmFtZSk7XG4gICAgdGhpcy51cGRhdGVGcmFtZSh0aGlzLnNjcm9sbFRvLmJpbmQodGhpcywgdGhpcy5wcm9wcy5pbml0aWFsSW5kZXgpKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAvLyBJZiB0aGUgbGlzdCBoYXMgcmVhY2hlZCBhbiB1bnN0YWJsZSBzdGF0ZSwgcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlxuICAgIGlmICh0aGlzLnVuc3RhYmxlKSByZXR1cm47XG5cbiAgICBpZiAoKyt0aGlzLnVwZGF0ZUNvdW50ZXIgPiBNQVhfU1lOQ19VUERBVEVTKSB7XG4gICAgICB0aGlzLnVuc3RhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFVOU1RBQkxFX01FU1NBR0UpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy51cGRhdGVDb3VudGVyVGltZW91dElkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvdW50ZXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVDb3VudGVyID0gMDtcbiAgICAgICAgZGVsZXRlIHRoaXMudXBkYXRlQ291bnRlclRpbWVvdXRJZDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICAvLyB0aGlzLmRvbnRVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlRnJhbWUoKTtcblxuICAgIC8vVE5SOiBleHRyYSBjb2RlIHRvICdmaXgnIHRoZSBzY3JvbGwgaGVpZ2h0IHdoZW4gc2Nyb2xsaW5nIHVwd2FyZHNcbiAgICAvL3RuciBjb21tZW50aW5nIHRoaXMgb3V0IGJlY2F1c2Ugd2UgYXJlIG5vdyBkb2luZyBhIGJldHRlciBqb2Igb2YgY2FsY3VsYXRpbmcgcm93IGhlaWdodHNcbiAgICAvLyBpZiAodGhpcy5yb3dUb0ZpeFNjcm9sbCkge1xuICAgIC8vICAgY29uc3QgeyByb3csIGNhY2hlOiBwcmV2aW91c1NpemUgfSA9IHRoaXMucm93VG9GaXhTY3JvbGw7XG4gICAgLy8gICBjb25zdCBhY3R1YWxTaXplID0gdGhpcy5jYWNoZVtyb3ddO1xuICAgIC8vICAgaWYgKGFjdHVhbFNpemUgJiYgYWN0dWFsU2l6ZSAhPT0gcHJldmlvdXNTaXplKSB7XG4gICAgLy8gICAgIHRoaXMuZ2V0U2Nyb2xsUGFyZW50KCkuc2Nyb2xsQnkoe1xuICAgIC8vICAgICAgIHRvcDogLShcbiAgICAvLyAgICAgICAgIChwcmV2aW91c1NpemUgfHwgdGhpcy5wcm9wcy5pdGVtU2l6ZUVzdGltYXRvcihyb3csIHt9KSkgLSBhY3R1YWxTaXplXG4gICAgLy8gICAgICAgKVxuICAgIC8vICAgICB9KTtcbiAgICAvLyAgICAgdGhpcy5yb3dUb0ZpeFNjcm9sbCA9IG51bGw7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICB9XG4gIC8vIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgLy8gICBpZiAodGhpcy5kb250VXBkYXRlKSB7XG4gIC8vICAgICB0aGlzLmRvbnRVcGRhdGUgPSBmYWxzZTtcbiAgLy8gICAgIHJldHVybiBmYWxzZTtcbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cbiAgbWF5YmVTZXRTdGF0ZShiLCBjYikge1xuICAgIGlmIChpc0VxdWFsU3Vic2V0KHRoaXMuc3RhdGUsIGIpKSByZXR1cm4gY2IoKTtcblxuICAgIC8vVE5SOiBleHRyYSBjb2RlIHRvICdmaXgnIHRoZSBzY3JvbGwgaGVpZ2h0IHdoZW4gc2Nyb2xsaW5nIHVwd2FyZHNcbiAgICBpZiAodGhpcy5zdGF0ZS5mcm9tID09PSBiLmZyb20gKyAxKSB7XG4gICAgICB0aGlzLnJvd1RvRml4U2Nyb2xsID0geyByb3c6IGIuZnJvbSwgY2FjaGU6IHRoaXMuY2FjaGVbYi5mcm9tXSB9O1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKGIsIGNiKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnVwZGF0ZUZyYW1lKTtcbiAgICB0aGlzLnNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnVwZGF0ZUZyYW1lLCBQQVNTSVZFKTtcbiAgICB0aGlzLnNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgTk9PUCwgUEFTU0lWRSk7XG4gIH1cblxuICBnZXRPZmZzZXQoZWwpIHtcbiAgICBjb25zdCB7IGF4aXMgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IG9mZnNldCA9IGVsW0NMSUVOVF9TVEFSVF9LRVlTW2F4aXNdXSB8fCAwO1xuICAgIGNvbnN0IG9mZnNldEtleSA9IE9GRlNFVF9TVEFSVF9LRVlTW2F4aXNdO1xuICAgIGRvIG9mZnNldCArPSBlbFtvZmZzZXRLZXldIHx8IDA7XG4gICAgd2hpbGUgKChlbCA9IGVsLm9mZnNldFBhcmVudCkpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBnZXRFbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbCB8fCB0aGlzLml0ZW1zO1xuICB9XG5cbiAgZ2V0U2Nyb2xsUGFyZW50KCkge1xuICAgIGNvbnN0IHsgYXhpcywgc2Nyb2xsUGFyZW50R2V0dGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChzY3JvbGxQYXJlbnRHZXR0ZXIpIHJldHVybiBzY3JvbGxQYXJlbnRHZXR0ZXIoKTtcbiAgICBsZXQgZWwgPSB0aGlzLmdldEVsKCk7XG4gICAgaWYgKCFlbCkgcmV0dXJuIHdpbmRvdztcbiAgICBjb25zdCBvdmVyZmxvd0tleSA9IE9WRVJGTE9XX0tFWVNbYXhpc107XG4gICAgd2hpbGUgKChlbCA9IGVsLnBhcmVudEVsZW1lbnQpKSB7XG4gICAgICBzd2l0Y2ggKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKVtvdmVyZmxvd0tleV0pIHtcbiAgICAgICAgY2FzZSAnYXV0byc6XG4gICAgICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICAgIGNhc2UgJ292ZXJsYXknOlxuICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGdldFNjcm9sbFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgc2Nyb2xsUGFyZW50IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYXhpcyB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBzY3JvbGxLZXkgPSBTQ1JPTExfU1RBUlRfS0VZU1theGlzXTtcbiAgICBjb25zdCBhY3R1YWwgPVxuICAgICAgc2Nyb2xsUGFyZW50ID09PSB3aW5kb3dcbiAgICAgICAgPyAvLyBGaXJlZm94IGFsd2F5cyByZXR1cm5zIGRvY3VtZW50LmJvZHlbc2Nyb2xsS2V5XSBhcyAwIGFuZCBDaHJvbWUvU2FmYXJpXG4gICAgICAgICAgLy8gYWx3YXlzIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbc2Nyb2xsS2V5XSBhcyAwLCBzbyB0YWtlXG4gICAgICAgICAgLy8gd2hpY2hldmVyIGhhcyBhIHZhbHVlLlxuICAgICAgICAgIGRvY3VtZW50LmJvZHlbc2Nyb2xsS2V5XSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbc2Nyb2xsS2V5XVxuICAgICAgICA6IHNjcm9sbFBhcmVudFtzY3JvbGxLZXldO1xuICAgIGNvbnN0IG1heCA9IHRoaXMuZ2V0U2Nyb2xsU2l6ZSgpIC0gdGhpcy5nZXRWaWV3cG9ydFNpemUoKTtcbiAgICBjb25zdCBzY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihhY3R1YWwsIG1heCkpO1xuICAgIGNvbnN0IGVsID0gdGhpcy5nZXRFbCgpO1xuICAgIHJldHVybiB0aGlzLmdldE9mZnNldChzY3JvbGxQYXJlbnQpICsgc2Nyb2xsIC0gdGhpcy5nZXRPZmZzZXQoZWwpO1xuICB9XG5cbiAgc2V0U2Nyb2xsKG9mZnNldCkge1xuICAgIGNvbnN0IHsgc2Nyb2xsUGFyZW50IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYXhpcyB9ID0gdGhpcy5wcm9wcztcbiAgICBvZmZzZXQgKz0gdGhpcy5nZXRPZmZzZXQodGhpcy5nZXRFbCgpKTtcbiAgICBpZiAoc2Nyb2xsUGFyZW50ID09PSB3aW5kb3cpIHJldHVybiB3aW5kb3cuc2Nyb2xsVG8oMCwgb2Zmc2V0KTtcblxuICAgIG9mZnNldCAtPSB0aGlzLmdldE9mZnNldCh0aGlzLnNjcm9sbFBhcmVudCk7XG4gICAgc2Nyb2xsUGFyZW50W1NDUk9MTF9TVEFSVF9LRVlTW2F4aXNdXSA9IG9mZnNldDtcbiAgfVxuXG4gIGdldFZpZXdwb3J0U2l6ZSgpIHtcbiAgICBjb25zdCB7IHNjcm9sbFBhcmVudCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGF4aXMgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIHNjcm9sbFBhcmVudCA9PT0gd2luZG93XG4gICAgICA/IHdpbmRvd1tJTk5FUl9TSVpFX0tFWVNbYXhpc11dXG4gICAgICA6IHNjcm9sbFBhcmVudFtDTElFTlRfU0laRV9LRVlTW2F4aXNdXTtcbiAgfVxuXG4gIGdldFNjcm9sbFNpemUoKSB7XG4gICAgY29uc3QgeyBzY3JvbGxQYXJlbnQgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBib2R5LCBkb2N1bWVudEVsZW1lbnQgfSA9IGRvY3VtZW50O1xuICAgIGNvbnN0IGtleSA9IFNDUk9MTF9TSVpFX0tFWVNbdGhpcy5wcm9wcy5heGlzXTtcbiAgICByZXR1cm4gc2Nyb2xsUGFyZW50ID09PSB3aW5kb3dcbiAgICAgID8gTWF0aC5tYXgoYm9keVtrZXldLCBkb2N1bWVudEVsZW1lbnRba2V5XSlcbiAgICAgIDogc2Nyb2xsUGFyZW50W2tleV07XG4gIH1cblxuICBoYXNEZXRlcm1pbmF0ZVNpemUoKSB7XG4gICAgY29uc3QgeyBpdGVtU2l6ZUdldHRlciwgdHlwZSB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3VuaWZvcm0nIHx8IGl0ZW1TaXplR2V0dGVyO1xuICB9XG5cbiAgZ2V0U3RhcnRBbmRFbmQodGhyZXNob2xkID0gdGhpcy5wcm9wcy50aHJlc2hvbGQpIHtcbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBzY3JvbGwgLSB0aHJlc2hvbGQpO1xuICAgIGxldCBlbmQgPSBzY3JvbGwgKyB0aGlzLmdldFZpZXdwb3J0U2l6ZSgpICsgdGhyZXNob2xkO1xuICAgIGlmICh0aGlzLmhhc0RldGVybWluYXRlU2l6ZSgpKSB7XG4gICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIHRoaXMuZ2V0U3BhY2VCZWZvcmUodGhpcy5wcm9wcy5sZW5ndGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICB9XG5cbiAgZ2V0SXRlbVNpemVBbmRJdGVtc1BlclJvdygpIHtcbiAgICBjb25zdCB7IGF4aXMsIHVzZVN0YXRpY1NpemUgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHsgaXRlbVNpemUsIGl0ZW1zUGVyUm93IH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh1c2VTdGF0aWNTaXplICYmIGl0ZW1TaXplICYmIGl0ZW1zUGVyUm93KSB7XG4gICAgICByZXR1cm4geyBpdGVtU2l6ZSwgaXRlbXNQZXJSb3cgfTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtRWxzID0gdGhpcy5pdGVtcy5jaGlsZHJlbjtcbiAgICBpZiAoIWl0ZW1FbHMubGVuZ3RoKSByZXR1cm4ge307XG5cbiAgICBjb25zdCBmaXJzdEVsID0gaXRlbUVsc1swXTtcblxuICAgIC8vIEZpcmVmb3ggaGFzIGEgcHJvYmxlbSB3aGVyZSBpdCB3aWxsIHJldHVybiBhICpzbGlnaHRseSogKGxlc3MgdGhhblxuICAgIC8vIHRob3VzYW5kdGhzIG9mIGEgcGl4ZWwpIGRpZmZlcmVudCBzaXplIGZvciB0aGUgc2FtZSBlbGVtZW50IGJldHdlZW5cbiAgICAvLyByZW5kZXJzLiBUaGlzIGNhbiBjYXVzZSBhbiBpbmZpbml0ZSByZW5kZXIgbG9vcCwgc28gb25seSBjaGFuZ2UgdGhlXG4gICAgLy8gaXRlbVNpemUgd2hlbiBpdCBpcyBzaWduaWZpY2FudGx5IGRpZmZlcmVudC5cbiAgICBjb25zdCBmaXJzdEVsU2l6ZSA9IGZpcnN0RWxbT0ZGU0VUX1NJWkVfS0VZU1theGlzXV07XG4gICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyhmaXJzdEVsU2l6ZSAtIGl0ZW1TaXplKTtcbiAgICBpZiAoaXNOYU4oZGVsdGEpIHx8IGRlbHRhID49IDEpIGl0ZW1TaXplID0gZmlyc3RFbFNpemU7XG5cbiAgICBpZiAoIWl0ZW1TaXplKSByZXR1cm4ge307XG5cbiAgICBjb25zdCBzdGFydEtleSA9IE9GRlNFVF9TVEFSVF9LRVlTW2F4aXNdO1xuICAgIGNvbnN0IGZpcnN0U3RhcnQgPSBmaXJzdEVsW3N0YXJ0S2V5XTtcbiAgICBpdGVtc1BlclJvdyA9IDE7XG4gICAgZm9yIChcbiAgICAgIGxldCBpdGVtID0gaXRlbUVsc1tpdGVtc1BlclJvd107XG4gICAgICBpdGVtICYmIGl0ZW1bc3RhcnRLZXldID09PSBmaXJzdFN0YXJ0O1xuICAgICAgaXRlbSA9IGl0ZW1FbHNbaXRlbXNQZXJSb3ddXG4gICAgKSB7XG4gICAgICArK2l0ZW1zUGVyUm93O1xuICAgIH1cblxuICAgIHJldHVybiB7IGl0ZW1TaXplLCBpdGVtc1BlclJvdyB9O1xuICB9XG5cbiAgdXBkYXRlRnJhbWUoY2IpIHtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbFBhcmVudCgpO1xuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gTk9PUDtcbiAgICBzd2l0Y2ggKHRoaXMucHJvcHMudHlwZSkge1xuICAgICAgY2FzZSAnc2ltcGxlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlU2ltcGxlRnJhbWUoY2IpO1xuICAgICAgY2FzZSAndmFyaWFibGUnOlxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVWYXJpYWJsZUZyYW1lKGNiKTtcbiAgICAgIGNhc2UgJ3VuaWZvcm0nOlxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVVbmlmb3JtRnJhbWUoY2IpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVNjcm9sbFBhcmVudCgpIHtcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5zY3JvbGxQYXJlbnQ7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgIHJldHVybjsgLy9odHRwczovL2dpdGh1Yi5jb20vY29kZXJpZXR5L3JlYWN0LWxpc3QvcHVsbC8xOTZcbiAgICB9XG4gICAgdGhpcy5zY3JvbGxQYXJlbnQgPSB0aGlzLmdldFNjcm9sbFBhcmVudCgpO1xuICAgIGlmIChwcmV2ID09PSB0aGlzLnNjcm9sbFBhcmVudCkgcmV0dXJuO1xuICAgIGlmIChwcmV2KSB7XG4gICAgICBwcmV2LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudXBkYXRlRnJhbWUpO1xuICAgICAgcHJldi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgTk9PUCk7XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudXBkYXRlRnJhbWUsIFBBU1NJVkUpO1xuICAgIHRoaXMuc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBOT09QLCBQQVNTSVZFKTtcbiAgfVxuXG4gIHVwZGF0ZVNpbXBsZUZyYW1lKGNiKSB7XG4gICAgY29uc3QgeyBlbmQgfSA9IHRoaXMuZ2V0U3RhcnRBbmRFbmQoKTtcbiAgICBjb25zdCBpdGVtRWxzID0gdGhpcy5pdGVtcy5jaGlsZHJlbjtcbiAgICBsZXQgZWxFbmQgPSAwO1xuXG4gICAgaWYgKGl0ZW1FbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7IGF4aXMgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCBmaXJzdEl0ZW1FbCA9IGl0ZW1FbHNbMF07XG4gICAgICBjb25zdCBsYXN0SXRlbUVsID0gaXRlbUVsc1tpdGVtRWxzLmxlbmd0aCAtIDFdO1xuICAgICAgZWxFbmQgPVxuICAgICAgICB0aGlzLmdldE9mZnNldChsYXN0SXRlbUVsKSArXG4gICAgICAgIGxhc3RJdGVtRWxbT0ZGU0VUX1NJWkVfS0VZU1theGlzXV0gLVxuICAgICAgICB0aGlzLmdldE9mZnNldChmaXJzdEl0ZW1FbCk7XG4gICAgfVxuXG4gICAgaWYgKGVsRW5kID4gZW5kKSByZXR1cm4gY2IoKTtcblxuICAgIGNvbnN0IHsgcGFnZVNpemUsIGxlbmd0aCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4odGhpcy5zdGF0ZS5zaXplICsgcGFnZVNpemUsIGxlbmd0aCk7XG4gICAgdGhpcy5tYXliZVNldFN0YXRlKHsgc2l6ZSB9LCBjYik7XG4gIH1cblxuICB1cGRhdGVWYXJpYWJsZUZyYW1lKGNiKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLml0ZW1TaXplR2V0dGVyKSB0aGlzLmNhY2hlU2l6ZXMoKTtcblxuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5nZXRTdGFydEFuZEVuZCgpO1xuICAgIGNvbnN0IHsgbGVuZ3RoLCBwYWdlU2l6ZSB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgc3BhY2UgPSAwO1xuICAgIGxldCBmcm9tID0gMDtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgY29uc3QgbWF4RnJvbSA9IGxlbmd0aCAtIDE7XG5cbiAgICB3aGlsZSAoZnJvbSA8IG1heEZyb20pIHtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gdGhpcy5nZXRTaXplT2ZJdGVtKGZyb20pO1xuICAgICAgaWYgKGl0ZW1TaXplID09IG51bGwgfHwgc3BhY2UgKyBpdGVtU2l6ZSA+IHN0YXJ0KSBicmVhaztcbiAgICAgIHNwYWNlICs9IGl0ZW1TaXplO1xuICAgICAgKytmcm9tO1xuICAgIH1cblxuICAgIGNvbnN0IG1heFNpemUgPSBsZW5ndGggLSBmcm9tO1xuXG4gICAgd2hpbGUgKHNpemUgPCBtYXhTaXplICYmIHNwYWNlIDwgZW5kKSB7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IHRoaXMuZ2V0U2l6ZU9mSXRlbShmcm9tICsgc2l6ZSk7XG4gICAgICBpZiAoaXRlbVNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gTWF0aC5taW4oc2l6ZSArIHBhZ2VTaXplLCBtYXhTaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzcGFjZSArPSBpdGVtU2l6ZTtcbiAgICAgICsrc2l6ZTtcbiAgICB9XG4gICAgdGhpcy5tYXliZVNldFN0YXRlKHsgZnJvbSwgc2l6ZSB9LCBjYik7XG4gIH1cblxuICB1cGRhdGVVbmlmb3JtRnJhbWUoY2IpIHtcbiAgICBjb25zdCB7IGl0ZW1TaXplLCBpdGVtc1BlclJvdyB9ID0gdGhpcy5nZXRJdGVtU2l6ZUFuZEl0ZW1zUGVyUm93KCk7XG5cbiAgICBpZiAoIWl0ZW1TaXplIHx8ICFpdGVtc1BlclJvdykgcmV0dXJuIGNiKCk7XG5cbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMuZ2V0U3RhcnRBbmRFbmQoKTtcblxuICAgIGNvbnN0IHsgZnJvbSwgc2l6ZSB9ID0gdGhpcy5jb25zdHJhaW4oXG4gICAgICBNYXRoLmZsb29yKHN0YXJ0IC8gaXRlbVNpemUpICogaXRlbXNQZXJSb3csXG4gICAgICAoTWF0aC5jZWlsKChlbmQgLSBzdGFydCkgLyBpdGVtU2l6ZSkgKyAxKSAqIGl0ZW1zUGVyUm93LFxuICAgICAgaXRlbXNQZXJSb3csXG4gICAgICB0aGlzLnByb3BzXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLm1heWJlU2V0U3RhdGUoeyBpdGVtc1BlclJvdywgZnJvbSwgaXRlbVNpemUsIHNpemUgfSwgY2IpO1xuICB9XG5cbiAgZ2V0U3BhY2VCZWZvcmUoaW5kZXgsIGNhY2hlID0ge30pIHtcbiAgICBpZiAoY2FjaGVbaW5kZXhdICE9IG51bGwpIHJldHVybiBjYWNoZVtpbmRleF07XG5cbiAgICAvLyBUcnkgdGhlIHN0YXRpYyBpdGVtU2l6ZS5cbiAgICBjb25zdCB7IGl0ZW1TaXplLCBpdGVtc1BlclJvdyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaXRlbVNpemUpIHtcbiAgICAgIHJldHVybiAoY2FjaGVbaW5kZXhdID0gTWF0aC5mbG9vcihpbmRleCAvIGl0ZW1zUGVyUm93KSAqIGl0ZW1TaXplKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHNwYWNlIHRvIGluZGV4IHRoZXJlIGlzIGEgY2FjaGVkIHZhbHVlIGZvci5cbiAgICBsZXQgZnJvbSA9IGluZGV4O1xuICAgIHdoaWxlIChmcm9tID4gMCAmJiBjYWNoZVstLWZyb21dID09IG51bGwpO1xuXG4gICAgLy8gRmluYWxseSwgYWNjdW11bGF0ZSBzaXplcyBvZiBpdGVtcyBmcm9tIC0gaW5kZXguXG4gICAgbGV0IHNwYWNlID0gY2FjaGVbZnJvbV0gfHwgMDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IGluZGV4OyArK2kpIHtcbiAgICAgIGNhY2hlW2ldID0gc3BhY2U7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IHRoaXMuZ2V0U2l6ZU9mSXRlbShpKTtcbiAgICAgIGlmIChpdGVtU2l6ZSA9PSBudWxsKSBicmVhaztcbiAgICAgIHNwYWNlICs9IGl0ZW1TaXplO1xuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVbaW5kZXhdID0gc3BhY2UpO1xuICB9XG5cbiAgY2FjaGVTaXplcygpIHtcbiAgICBjb25zdCB7IGNhY2hlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZnJvbSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIXRoaXMuaXRlbXMpIHJldHVybjtcbiAgICBjb25zdCBpdGVtRWxzID0gdGhpcy5pdGVtcy5jaGlsZHJlbjtcbiAgICBjb25zdCBzaXplS2V5ID0gT0ZGU0VUX1NJWkVfS0VZU1t0aGlzLnByb3BzLmF4aXNdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gaXRlbUVscy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGNhY2hlW2Zyb20gKyBpXSA9IGl0ZW1FbHNbaV1bc2l6ZUtleV07XG4gICAgfVxuICB9XG5cbiAgZ2V0U2l6ZU9mSXRlbShpbmRleCkge1xuICAgIGNvbnN0IHsgY2FjaGUsIGl0ZW1zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYXhpcywgaXRlbVNpemVHZXR0ZXIsIGl0ZW1TaXplRXN0aW1hdG9yLCB0eXBlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZnJvbSwgaXRlbVNpemUsIHNpemUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAvLyBUcnkgdGhlIHN0YXRpYyBpdGVtU2l6ZS5cbiAgICBpZiAoaXRlbVNpemUpIHJldHVybiBpdGVtU2l6ZTtcblxuICAgIC8vIFRyeSB0aGUgaXRlbVNpemVHZXR0ZXIuXG4gICAgaWYgKGl0ZW1TaXplR2V0dGVyKSByZXR1cm4gaXRlbVNpemVHZXR0ZXIoaW5kZXgpO1xuXG4gICAgLy8gVHJ5IHRoZSBjYWNoZS5cbiAgICBpZiAoaW5kZXggaW4gY2FjaGUpIHJldHVybiBjYWNoZVtpbmRleF07XG5cbiAgICAvLyBUcnkgdGhlIERPTS5cbiAgICBpZiAodHlwZSA9PT0gJ3NpbXBsZScgJiYgaW5kZXggPj0gZnJvbSAmJiBpbmRleCA8IGZyb20gKyBzaXplICYmIGl0ZW1zKSB7XG4gICAgICBjb25zdCBpdGVtRWwgPSBpdGVtcy5jaGlsZHJlbltpbmRleCAtIGZyb21dO1xuICAgICAgaWYgKGl0ZW1FbCkgcmV0dXJuIGl0ZW1FbFtPRkZTRVRfU0laRV9LRVlTW2F4aXNdXTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdGhlIGl0ZW1TaXplRXN0aW1hdG9yLlxuICAgIGlmIChpdGVtU2l6ZUVzdGltYXRvcikgcmV0dXJuIGl0ZW1TaXplRXN0aW1hdG9yKGluZGV4LCBjYWNoZSk7XG4gIH1cblxuICBjb25zdHJhaW4oZnJvbSwgc2l6ZSwgaXRlbXNQZXJSb3csIHsgbGVuZ3RoLCBtaW5TaXplLCB0eXBlIH0pIHtcbiAgICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgbWluU2l6ZSk7XG4gICAgbGV0IG1vZCA9IHNpemUgJSBpdGVtc1BlclJvdztcbiAgICBpZiAobW9kKSBzaXplICs9IGl0ZW1zUGVyUm93IC0gbW9kO1xuICAgIGlmIChzaXplID4gbGVuZ3RoKSBzaXplID0gbGVuZ3RoO1xuICAgIGZyb20gPVxuICAgICAgdHlwZSA9PT0gJ3NpbXBsZScgfHwgIWZyb21cbiAgICAgICAgPyAwXG4gICAgICAgIDogTWF0aC5tYXgoTWF0aC5taW4oZnJvbSwgbGVuZ3RoIC0gc2l6ZSksIDApO1xuXG4gICAgaWYgKChtb2QgPSBmcm9tICUgaXRlbXNQZXJSb3cpKSB7XG4gICAgICBmcm9tIC09IG1vZDtcbiAgICAgIHNpemUgKz0gbW9kO1xuICAgIH1cblxuICAgIHJldHVybiB7IGZyb20sIHNpemUgfTtcbiAgfVxuXG4gIHNjcm9sbFRvKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHRoaXMuc2V0U2Nyb2xsKHRoaXMuZ2V0U3BhY2VCZWZvcmUoaW5kZXgpIC0gMTAwKTtcbiAgfVxuXG4gIHNjcm9sbEFyb3VuZChpbmRleCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy5nZXRTcGFjZUJlZm9yZShpbmRleCk7XG4gICAgY29uc3QgdG9wID0gYm90dG9tIC0gdGhpcy5nZXRWaWV3cG9ydFNpemUoKSArIHRoaXMuZ2V0U2l6ZU9mSXRlbShpbmRleCk7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4odG9wLCBib3R0b20pO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHRvcCwgYm90dG9tKTtcbiAgICBpZiAoY3VycmVudCA8PSBtaW4pIHJldHVybiB0aGlzLnNldFNjcm9sbChtaW4gLSB0aGlzLmdldFZpZXdwb3J0U2l6ZSgpKTtcbiAgICBpZiAoY3VycmVudCA+IG1heCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U2Nyb2xsKG1heCAtIHRoaXMuZ2V0Vmlld3BvcnRTaXplKCkgLSAxMDApO1xuICAgIH1cbiAgfVxuXG4gIGdldFZpc2libGVSYW5nZSgpIHtcbiAgICBjb25zdCB7IGZyb20sIHNpemUgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLmdldFN0YXJ0QW5kRW5kKDApO1xuICAgIGNvbnN0IGNhY2hlID0ge307XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgZnJvbSArIHNpemU7ICsraSkge1xuICAgICAgY29uc3QgaXRlbVN0YXJ0ID0gdGhpcy5nZXRTcGFjZUJlZm9yZShpLCBjYWNoZSk7XG4gICAgICBjb25zdCBpdGVtRW5kID0gaXRlbVN0YXJ0ICsgdGhpcy5nZXRTaXplT2ZJdGVtKGkpO1xuICAgICAgaWYgKGZpcnN0ID09IG51bGwgJiYgaXRlbUVuZCA+IHN0YXJ0KSBmaXJzdCA9IGk7XG4gICAgICBpZiAoZmlyc3QgIT0gbnVsbCAmJiBpdGVtU3RhcnQgPCBlbmQpIGxhc3QgPSBpO1xuICAgIH1cbiAgICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcbiAgfVxuICAvL3RoaXMgY2FuIGJlIHVzZWQgYXMgYSBzdGF0aWMgbWV0aG9kIHZpYSB0aGUgcmVhY3QgbGlzdCByZWZcbiAgZ2V0RnJhY3Rpb25hbFZpc2libGVSYW5nZSgpIHtcbiAgICBjb25zdCB7IGZyb20sIHNpemUgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLmdldFN0YXJ0QW5kRW5kKDApO1xuICAgIGNvbnN0IGNhY2hlID0ge307XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuXG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCBmcm9tICsgc2l6ZTsgKytpKSB7XG4gICAgICBjb25zdCBpdGVtU3RhcnQgPSB0aGlzLmdldFNwYWNlQmVmb3JlKGksIGNhY2hlKTtcbiAgICAgIGNvbnN0IGl0ZW1FbmQgPSBpdGVtU3RhcnQgKyB0aGlzLmdldFNpemVPZkl0ZW0oaSk7XG4gICAgICBpZiAoZmlyc3QgPT0gbnVsbCAmJiBpdGVtRW5kID4gc3RhcnQpIHtcbiAgICAgICAgZmlyc3QgPSBpICsgMSAtIChpdGVtRW5kIC0gc3RhcnQpIC8gKGl0ZW1FbmQgLSBpdGVtU3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0ICE9IG51bGwgJiYgaXRlbVN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIGxhc3QgPSBpIC0gKGl0ZW1FbmQgLSBlbmQpIC8gKGl0ZW1FbmQgLSBpdGVtU3RhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcbiAgfVxuXG4gIHJlbmRlckl0ZW1zKCkge1xuICAgIGNvbnN0IHsgaXRlbVJlbmRlcmVyLCBpdGVtc1JlbmRlcmVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZnJvbSwgc2l6ZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgKytpKSBpdGVtcy5wdXNoKGl0ZW1SZW5kZXJlcihmcm9tICsgaSwgaSkpO1xuICAgIHJldHVybiBpdGVtc1JlbmRlcmVyKGl0ZW1zLCBjID0+ICh0aGlzLml0ZW1zID0gYykpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgYXhpcywgbGVuZ3RoLCB0eXBlIC8qIHVzZVRyYW5zbGF0ZTNkICovIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZnJvbSwgaXRlbXNQZXJSb3cgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLnJlbmRlckl0ZW1zKCk7XG4gICAgaWYgKHR5cGUgPT09ICdzaW1wbGUnKSByZXR1cm4gaXRlbXM7XG5cbiAgICBjb25zdCBzdHlsZSA9IHsgcG9zaXRpb246ICdyZWxhdGl2ZScgfTtcbiAgICBjb25zdCBjYWNoZSA9IHt9O1xuICAgIGNvbnN0IGJvdHRvbSA9IE1hdGguY2VpbChsZW5ndGggLyBpdGVtc1BlclJvdykgKiBpdGVtc1BlclJvdztcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTcGFjZUJlZm9yZShib3R0b20sIGNhY2hlKTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgc3R5bGVbU0laRV9LRVlTW2F4aXNdXSA9IHNpemU7XG4gICAgICBpZiAoYXhpcyA9PT0gJ3gnKSBzdHlsZS5vdmVyZmxvd1ggPSAnaGlkZGVuJztcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5nZXRTcGFjZUJlZm9yZShmcm9tLCBjYWNoZSk7XG4gICAgY29uc3QgeCA9IGF4aXMgPT09ICd4JyA/IG9mZnNldCA6IDA7XG4gICAgY29uc3QgeSA9IGF4aXMgPT09ICd5JyA/IG9mZnNldCA6IDA7XG4gICAgY29uc3QgbGlzdFN0eWxlID0ge1xuICAgICAgLy90bnIgdHJ5aW5nIG91dDogaHR0cHM6Ly9naXRodWIuY29tL2NvZGVyaWV0eS9yZWFjdC1saXN0L3B1bGwvMTU0XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHRvcDogeSxcbiAgICAgIGxlZnQ6IHhcbiAgICB9O1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgcmVmPXtjID0+IHtcbiAgICAgICAgICBpZiAoYykgdGhpcy5lbCA9IGM7XG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIDxkaXYgc3R5bGU9e2xpc3RTdHlsZX0+e2l0ZW1zfTwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIl19