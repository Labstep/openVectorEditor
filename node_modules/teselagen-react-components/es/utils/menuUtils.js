var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

import React from "react";
import { lifecycle, compose, branch } from "recompose";
import { withRouter } from "react-router-dom";
import { MenuItem, MenuDivider, Tooltip, KeyCombo, ContextMenu, Menu } from "@blueprintjs/core";
import { startCase, omit } from "lodash";

var noop = function noop() {};

// Enhanced MenuItem that supports history-based navigation when passed a
// `navTo` prop
var EnhancedMenuItem = compose(lifecycle({
  componentDidMount: function componentDidMount() {
    var _props = this.props,
        _props$didMount = _props.didMount,
        didMount = _props$didMount === undefined ? noop : _props$didMount,
        className = _props.className;

    didMount({ className: className });
  },
  componentWillUnmount: function componentWillUnmount() {
    var _props2 = this.props,
        _props2$willUnmount = _props2.willUnmount,
        willUnmount = _props2$willUnmount === undefined ? noop : _props2$willUnmount,
        className = _props2.className;

    willUnmount({ className: className });
  }
}), branch(function (_ref) {
  var navTo = _ref.navTo;
  return navTo;
}, withRouter))(function (_ref2) {
  var navTo = _ref2.navTo,
      context = _ref2.context,
      staticContext = _ref2.staticContext,
      didMount = _ref2.didMount,
      willUnmount = _ref2.willUnmount,
      props = _objectWithoutProperties(_ref2, ["navTo", "context", "staticContext", "didMount", "willUnmount"]);

  var clickHandler = props.onClick ? function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return props.onClick.apply(props, args.concat([context]));
  } : undefined;
  if (navTo) {
    clickHandler = function clickHandler(e) {
      if (e.metaKey || e.ctrlKey) {
        window.open(props.history.createHref({ pathname: navTo }));
      } else {
        props.history.push(navTo);
      }
      if (props.onClick) props.onClick(e);
    };
  }
  return React.createElement(MenuItem, _extends({
    popoverProps: {
      autoFocus: false
    }
  }, props, {
    onClick: clickHandler
  }));
});

// First Non-Undefined
export { EnhancedMenuItem };
function fnu() {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return args.find(function (v) {
    return v !== undefined;
  });
}

// Sets a tick icon if items has a `checked` prop
export var tickMenuEnhancer = function tickMenuEnhancer(def) {
  var out = _extends({}, def);
  if (out.checked !== undefined) {
    out.icon = out.checked ? "small-tick" : "blank";
  }
  return out;
};

// Derives various menu item props based on command objects matched via the `cmd`
// prop. Derived props include `text`, `icon`, `hotkey`, `onClick` and `disabled`.
export var commandMenuEnhancer = function commandMenuEnhancer(commands) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (def, context) {
    var cmdId = typeof def === "string" ? def : def.cmd;
    var item = typeof def === "string" ? { cmd: def } : _extends({}, def);

    var useTicks = fnu(item.useTicks, config.useTicks);
    delete item.useTicks;

    if (cmdId && commands[cmdId] && def.divider === undefined) {
      var command = commands[cmdId];

      var isActive = command.isActive,
          isDisabled = command.isDisabled,
          isHidden = command.isHidden;

      var toggles = isActive !== undefined;

      item.hidden = fnu(item.hidden, isHidden);
      item.disabled = fnu(item.disabled, isDisabled);

      item.key = item.key || cmdId;
      item.submenu = item.submenu || command.submenu;

      if (toggles) {
        if (useTicks) {
          item.text = item.text || command.shortName || command.name;
          item.checked = item.checked || isActive;
        } else {
          item.text = item.text || (isActive ? command.name : command.inactiveName || command.name);
          item.icon = item.icon || (isActive ? command.icon : command.inactiveIcon || command.icon);
        }
      } else {
        item.text = item.text || command.name;
        item.icon = item.icon || command.icon;
      }

      item.hotkey = item.hotkey || command.hotkey;
      if (!item.onClick) {
        item.onClick = function (event) {
          return command.execute({
            event: event,
            context: context,
            menuItem: item,
            viaMenu: true
          });
        };
      }
    } else if (cmdId && !commands[cmdId]) {
      item.text = item.text || startCase(cmdId);
      item.disabled = true;
    }

    if (config.omitIcons) {
      item.icon = undefined;
    }

    if (config.forceIconAlignment !== false) {
      item.icon = item.icon || "blank";
    }

    if (useTicks) {
      item = tickMenuEnhancer(item);
    }

    return item;
  };
};

var ident = function ident(x) {
  return x;
};

var dividerShorthandEnhancer = function dividerShorthandEnhancer(def) {
  return typeof def === "string" && def.startsWith("--") ? { divider: def.substr(2) } : def;
};

// filter out unwanted attributes here! we won't want these to show up on the dom element or react will give nasty warnings
var unwantedAttrs = ["submenu", "hotkey", "showInSearchMenu", "hideFromMenuSearch"];

/** A menu item component that adds many features over the standard MenuItem,
 * and allows for dynamic menu structures that are computed efficiently (only
 * visible sections are computed and rendered).
 * TODO: document and add examples
 */
export var DynamicMenuItem = function DynamicMenuItem(_ref3) {
  var def = _ref3.def,
      _ref3$enhancers = _ref3.enhancers,
      enhancers = _ref3$enhancers === undefined ? [ident] : _ref3$enhancers,
      context = _ref3.context,
      doNotEnhanceTopLevelItem = _ref3.doNotEnhanceTopLevelItem;

  // If passed an element instead of a menu item definition, return it.
  // This allows mixing menu item elements and menu item defs, and makes it
  // safe to call menu creation utils with their own output.
  if (React.isValidElement(def)) return def;

  var item = [dividerShorthandEnhancer].concat(doNotEnhanceTopLevelItem ? [ident] : enhancers).reduce(function (v, f) {
    return f(v, context);
  }, def);
  var out = void 0;

  if (item.divider !== undefined) {
    out = React.createElement(MenuDivider, item.divider ? { title: item.divider } : {});
  } else {
    var ItemComponent = item.component || EnhancedMenuItem;
    out = React.createElement(
      ItemComponent
      // filter out unwanted attributes here!
      ,
      _extends({}, omit(item, unwantedAttrs), {
        context: context,
        icon: item.icon || item.iconName,
        labelElement: item.hotkey && React.createElement(KeyCombo, { minimal: true, combo: item.hotkey }),
        text: item.text
      }),
      item.submenu ? item.submenu.filter(ident).map(function (def, index) {
        return React.createElement(DynamicMenuItem, _extends({ def: def, enhancers: enhancers, context: context }, { key: index }));
      }) : undefined
    );
  }
  // if (item.disabled && item.disabledTooltip) {
  //   item.tooltip = def.disabledTooltip
  // }
  if (item.disabled && typeof item.disabled === "string") {
    item.tooltip = item.disabled;
  }

  if (item.tooltip) {
    out = React.createElement(
      Tooltip,
      { content: item.tooltip },
      out
    );
  }

  return item.hidden ? null : out;
};

// Map the passed item definition(s) to DynamicMenuItem elements
export var createDynamicMenu = function createDynamicMenu(menuDef, enhancers, context) {
  if (menuDef instanceof Array) {
    return menuDef.map(function (def, index) {
      return React.createElement(DynamicMenuItem, _extends({ def: def, enhancers: enhancers, context: context }, { key: index }));
    });
  } else {
    return React.createElement(DynamicMenuItem, { def: menuDef, enhancers: enhancers, context: context });
  }
};

// Create a "bar" menu, keeping the top level array unchanged, and only
// map their submenus to DynamicMenuItem elements
export var createDynamicBarMenu = function createDynamicBarMenu(topMenuDef, enhancers, context) {
  return topMenuDef.map(function (topLevelItem) {
    var def = _extends({}, topLevelItem);
    if (def.submenu) {
      def.submenu = def.submenu.map(function (subdef, index) {
        return React.createElement(DynamicMenuItem, _extends({ def: subdef }, { enhancers: enhancers, context: context }, { key: index }));
      });
    }
    return def;
  });
};

// Shorthand for command-based menus
export var createCommandMenu = function createCommandMenu(menuDef, commands, config, context) {
  return createDynamicMenu(menuDef, [commandMenuEnhancer(commands, config)], context);
};

// Shorthand for command-based bar menus
export var createCommandBarMenu = function createCommandBarMenu(menuDef, commands, config, context) {
  return createDynamicBarMenu(menuDef, [commandMenuEnhancer(commands, config)], context);
};

export function showCommandContextMenu(menuDef, commands, config, event, onClose, context) {
  return showContextMenu(menuDef, [commandMenuEnhancer(commands, config)], context, event, onClose);
}

/**
 * TODO: update documentation. This is now an alias of createDynamicMenu
 *
 * Creates the contents of a Blueprint menu based on a given menu structure.
 *
 * The input can be an array of item objects, where each may contain:
 * text: text to show
 * key: React key to use (optional)
 * divider: indicates it's a divider instead of an item. Use an empty string
 *   for a normal divider, or some label text for a labeled one
 * icon: name of icon to show (optional)
 * label: right-aligned label, used mostly for shortcuts (optional)
 * hotkey: right-aligned label formatted with <KeyCombo> (optional)
 * tooltip: tooltip text to use (optional)
 * submenu: nested menu structure describing submenu (i.e. array of item objects),
 *   or array of MenuItem elements
 * onClick: click handler
 * navTo: a url to navigate to (assumes react-router)
 * href: a url to link to
 * target: link target
 *
 * Since this function is recursive (to handle nested submenus), and React
 * elements passed as input are returned unchanged, it is possible to freely mix
 * item objects and MenuItem elements. That also makes it safe to call the function
 * with its own output.
 *
 * A customize function may also be provided, and allows customization or
 * replacement of the created MenuItems, allowing for custom props or behavior.
 * That function receives the original created element and the item object, and
 * must return an element.
 *
 * Usage example:
 *
 * const menu = createMenu([
 *   { text: 'Item One', icon: 'add', onClick: () => console.info('Clicked 1') },
 *   { text: 'Item One', onClick: () => console.info('Clicked 2') },
 *   { divider: '' },
 *   { text: 'Item Three', icon: 'numerical', onClick: () => console.info('Clicked 3') },
 *   { divider: '' },
 *   { text: 'Submenus', submenu: [
 *     { text: 'Sub One' },
 *     { text: 'Sub Two' },
 *   ]},
 * ]);
 *
 */
export var createMenu = createDynamicMenu;

export function showContextMenu(menuDef, enhancers, event, onClose, context) {
  var menuComp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Menu;

  menuDef = filterMenuForCorrectness(menuDef);
  if (!menuDef) return;

  var MenuComponent = menuComp;
  event.persist();
  // Render a context menu at the passed event's position
  ContextMenu.show(React.createElement(
    MenuComponent,
    null,
    createDynamicMenu(menuDef, enhancers, context)
  ), { left: event.clientX, top: event.clientY }, onClose);
  event.stopPropagation && event.stopPropagation();
  event.preventDefault && event.preventDefault();
}

function filterMenuForCorrectness(menuDef) {
  return menuDef && menuDef.length && menuDef.filter(ident);
}