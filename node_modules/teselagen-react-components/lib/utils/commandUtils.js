"use strict";

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.genericCommandFactory = genericCommandFactory;
exports.getCommandHotkeys = getCommandHotkeys;
exports.getCommandHandlers = getCommandHandlers;
exports.getCommandHotkeyHandlers = getCommandHotkeyHandlers;

var _lodash = require("lodash");

// Generic factory function to create command objects.
// TODO add documentation
function genericCommandFactory(config) {
  var out = {};

  var _loop = function _loop(cmdId) {
    var def = config.commandDefs[cmdId];
    var command = { id: cmdId };
    command.execute = function () {
      for (var _len = arguments.length, execArgs = Array(_len), _key = 0; _key < _len; _key++) {
        execArgs[_key] = arguments[_key];
      }

      config.handleReturn(cmdId, def.handler && def.handler.apply(command, config.getArguments(cmdId, execArgs)));
    };

    var properties = ["icon", "name", "shortName", "description", "hotkey", "hotkeyProps", "isDisabled", "submenu", "isActive", "isHidden", "tooltip", "inactiveIcon", "inactiveName"];

    properties.forEach(function (prop) {
      if (def[prop] !== undefined) {
        if (typeof def[prop] === "function") {
          Object.defineProperty(command, prop, {
            get: function get() {
              return def[prop].apply(command, config.getArguments(cmdId, []));
            }
          });
        } else {
          command[prop] = def[prop];
        }
      }
    });

    // If no name was specified in the definition, let's try to give some
    // auto-generated names
    if (!def.name) {
      command.name = (0, _lodash.startCase)(cmdId);
      if (def.toggle && cmdId.startsWith("toggle")) {
        command.name = (0, _lodash.startCase)(cmdId.replace("toggle", def.toggle[0] || ""));
        command.inactiveName = (0, _lodash.startCase)(cmdId.replace("toggle", def.toggle[1] || ""));
        command.shortName = (0, _lodash.startCase)(cmdId.replace("toggle", ""));
      }
    }

    out[cmdId] = command;
  };

  for (var cmdId in config.commandDefs) {
    _loop(cmdId);
  }

  return out;
}

// Extract hotkey props from the given commands or command defs, returning
// a mapping of command ids to hotkey prop objects
function getCommandHotkeys(commandsOrDefs) {
  var hotkeyDefs = {};
  Object.keys(commandsOrDefs).forEach(function (cmdId) {
    if (commandsOrDefs[cmdId].hotkey) {
      hotkeyDefs[cmdId] = _extends({
        combo: commandsOrDefs[cmdId].hotkey,
        label: commandsOrDefs[cmdId].name || (0, _lodash.startCase)(cmdId)
      }, commandsOrDefs[cmdId].hotkeyProps);
    }
  });

  return hotkeyDefs;
}

// Extract handler functions from the given commands, returning a mapping of
// command ids to handlers (directly - no checks added).
function getCommandHandlers(commands) {
  var handlers = {};
  Object.keys(commands).forEach(function (cmdId) {
    handlers[cmdId] = commands[cmdId].execute;
  });

  return handlers;
}

// Get hotkey handler functions for the given commands, returning a mapping of
// command ids to hotkey handlers.
function getCommandHotkeyHandlers(commands) {
  var handlers = {};
  Object.keys(commands).forEach(function (cmdId) {
    if (commands[cmdId].hotkey) {
      handlers[cmdId] = function (event) {
        if (!commands[cmdId].isDisabled && !commands[cmdId].isHidden) {
          commands[cmdId].execute({ event: event, viaHotkey: true });
        }
      };
    }
  });

  return handlers;
}